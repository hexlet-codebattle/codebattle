require 'json'
require 'stringio'
require 'test/unit'

extend Test::Unit::Assertions

original_stdout = $stdout
$stdout = StringIO.new

@execution_result = []

begin
  require './check/solution'

  success = true

  def assert_result(solution, expected, arguments, success)
    begin
      start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      result = solution.call(*arguments)
      finish = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      assert_equal(expected, result)

      @execution_result <<
        JSON.dump(
          status: :success,
          result: result,
          output: $stdout.string,
          arguments: arguments,
          execution_time: finish - start
        )
      success
    rescue Test::Unit::AssertionFailedError
      @execution_result <<
        JSON.dump(
          status: :failure,
          result: result,
          output: $stdout.string,
          expected: expected,
          arguments: arguments,
          execution_time: finish - start
        )
      false
    end
  end

  <%= for %{arguments: arguments, expected: expected} <- checks do %>
    success = assert_result(method(:solution), <%= expected %>, [<%= arguments %>], success)
  <% end %>

  if success
    @execution_result <<
      JSON.dump(
        status: :ok,
        result: <%= hash_sum %>
      )
  end
rescue Exception => e
  @execution_result <<
    JSON.dump(
      status: :error,
      result: e.message
    )
end

$stdout = original_stdout
puts @execution_result
