// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f https://github.com/envoyproxy/gateway/releases/download/v1.3.0/install.yaml

package v1alpha1

import (
	"strings"
	"list"
)

// SecurityPolicy allows the user to configure various security
// settings for a
// Gateway.
#SecurityPolicy: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "gateway.envoyproxy.io/v1alpha1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "SecurityPolicy"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// Spec defines the desired state of SecurityPolicy.
	spec!: #SecurityPolicySpec
}

// Spec defines the desired state of SecurityPolicy.
#SecurityPolicySpec: {
	// APIKeyAuth defines the configuration for the API Key
	// Authentication.
	apiKeyAuth?: {
		// CredentialRefs is the Kubernetes secret which contains the API
		// keys.
		// This is an Opaque secret.
		// Each API key is stored in the key representing the client id.
		// If the secrets have a key for a duplicated client, the first
		// one will be used.
		credentialRefs!: [...{
			// Group is the group of the referent. For example,
			// "gateway.networking.k8s.io".
			// When unspecified or empty string, core API group is inferred.
			group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

			// Kind is kind of the referent. For example "Secret".
			kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Secret"

			// Name is the name of the referent.
			name!: strings.MaxRunes(253) & strings.MinRunes(1)

			// Namespace is the namespace of the referenced object. When
			// unspecified, the local
			// namespace is inferred.
			//
			// Note that when a namespace different than the local namespace
			// is specified,
			// a ReferenceGrant object is required in the referent namespace
			// to allow that
			// namespace's owner to accept the reference. See the
			// ReferenceGrant
			// documentation for details.
			//
			// Support: Core
			namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
			}
		}]

		// ExtractFrom is where to fetch the key from the coming request.
		// The value from the first source that has a key will be used.
		extractFrom!: [...{
			// Cookies is the names of the cookie to fetch the key from.
			// If multiple cookies are specified, envoy will look for the api
			// key in the order of the list.
			// This field is optional, but only one of headers, params or
			// cookies is supposed to be specified.
			cookies?: [...string]

			// Headers is the names of the header to fetch the key from.
			// If multiple headers are specified, envoy will look for the api
			// key in the order of the list.
			// This field is optional, but only one of headers, params or
			// cookies is supposed to be specified.
			headers?: [...string]

			// Params is the names of the query parameter to fetch the key
			// from.
			// If multiple params are specified, envoy will look for the api
			// key in the order of the list.
			// This field is optional, but only one of headers, params or
			// cookies is supposed to be specified.
			params?: [...string]
		}]
	}

	// Authorization defines the authorization configuration.
	authorization?: {
		// DefaultAction defines the default action to be taken if no
		// rules match.
		// If not specified, the default action is Deny.
		defaultAction?: "Allow" | "Deny"

		// Rules defines a list of authorization rules.
		// These rules are evaluated in order, the first matching rule
		// will be applied,
		// and the rest will be skipped.
		//
		// For example, if there are two rules: the first rule allows the
		// request
		// and the second rule denies it, when a request matches both
		// rules, it will be allowed.
		rules?: [...{
			// Action defines the action to be taken if the rule matches.
			action!: "Allow" | "Deny"

			// Name is a user-friendly name for the rule.
			// If not specified, Envoy Gateway will generate a unique name for
			// the rule.
			name?: strings.MaxRunes(253) & strings.MinRunes(1)

			// Principal specifies the client identity of a request.
			// If there are multiple principal types, all principals must
			// match for the rule to match.
			// For example, if there are two principals: one for client IP and
			// one for JWT claim,
			// the rule will match only if both the client IP and the JWT
			// claim match.
			principal!: {
				// ClientCIDRs are the IP CIDR ranges of the client.
				// Valid examples are "192.168.1.0/24" or "2001:db8::/64"
				//
				// If multiple CIDR ranges are specified, one of the CIDR ranges
				// must match
				// the client IP for the rule to match.
				//
				// The client IP is inferred from the X-Forwarded-For header, a
				// custom header,
				// or the proxy protocol.
				// You can use the `ClientIPDetection` or the
				// `EnableProxyProtocol` field in
				// the `ClientTrafficPolicy` to configure how the client IP is
				// detected.
				clientCIDRs?: [...=~"((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]+))|((([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/([0-9]+))"] & [_, ...]

				// JWT authorize the request based on the JWT claims and scopes.
				// Note: in order to use JWT claims for authorization, you must
				// configure the
				// JWT authentication in the same `SecurityPolicy`.
				jwt?: {
					// Claims are the claims in a JWT token.
					//
					// If multiple claims are specified, all claims must match for the
					// rule to match.
					// For example, if there are two claims: one for the audience and
					// one for the issuer,
					// the rule will match only if both the audience and the issuer
					// match.
					claims?: list.MaxItems(16) & [...{
						// Name is the name of the claim.
						// If it is a nested claim, use a dot (.) separated string as the
						// name to
						// represent the full path to the claim.
						// For example, if the claim is in the "department" field in the
						// "organization" field,
						// the name should be "organization.department".
						name!: strings.MaxRunes(253) & strings.MinRunes(1)

						// ValueType is the type of the claim value.
						// Only String and StringArray types are supported for now.
						valueType?: "String" | "StringArray" | *"String"

						// Values are the values that the claim must match.
						// If the claim is a string type, the specified value must match
						// exactly.
						// If the claim is a string array type, the specified value must
						// match one of the values in the array.
						// If multiple values are specified, one of the values must match
						// for the rule to match.
						values!: list.MaxItems(16) & [...string] & [_, ...]
					}] & [_, ...]

					// Provider is the name of the JWT provider that used to verify
					// the JWT token.
					// In order to use JWT claims for authorization, you must
					// configure the JWT
					// authentication with the same provider in the same
					// `SecurityPolicy`.
					provider!: strings.MaxRunes(253) & strings.MinRunes(1)

					// Scopes are a special type of claim in a JWT token that
					// represents the permissions of the client.
					//
					// The value of the scopes field should be a space delimited
					// string that is expected in the scope parameter,
					// as defined in RFC 6749:
					// https://datatracker.ietf.org/doc/html/rfc6749#page-23.
					//
					// If multiple scopes are specified, all scopes must match for the
					// rule to match.
					scopes?: list.MaxItems(16) & [...strings.MaxRunes(253) & strings.MinRunes(1)] & [_, ...]
				}
			}
		}]
	}
	basicAuth?: {
		// The Kubernetes secret which contains the username-password
		// pairs in
		// htpasswd format, used to verify user credentials in the
		// "Authorization"
		// header.
		//
		// This is an Opaque secret. The username-password pairs should be
		// stored in
		// the key ".htpasswd". As the key name indicates, the value needs
		// to be the
		// htpasswd format, for example:
		// "user1:{SHA}hashed_user1_password".
		// Right now, only SHA hash algorithm is supported.
		// Reference to
		// https://httpd.apache.org/docs/2.4/programs/htpasswd.html
		// for more details.
		//
		// Note: The secret must be in the same namespace as the
		// SecurityPolicy.
		users!: {
			// Group is the group of the referent. For example,
			// "gateway.networking.k8s.io".
			// When unspecified or empty string, core API group is inferred.
			group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

			// Kind is kind of the referent. For example "Secret".
			kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Secret"

			// Name is the name of the referent.
			name!: strings.MaxRunes(253) & strings.MinRunes(1)

			// Namespace is the namespace of the referenced object. When
			// unspecified, the local
			// namespace is inferred.
			//
			// Note that when a namespace different than the local namespace
			// is specified,
			// a ReferenceGrant object is required in the referent namespace
			// to allow that
			// namespace's owner to accept the reference. See the
			// ReferenceGrant
			// documentation for details.
			//
			// Support: Core
			namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
			}
		}
	}

	// CORS defines the configuration for Cross-Origin Resource
	// Sharing (CORS).
	cors?: {
		// AllowCredentials indicates whether a request can include user
		// credentials
		// like cookies, authentication headers, or TLS client
		// certificates.
		// It specifies the value in the Access-Control-Allow-Credentials
		// CORS response header.
		allowCredentials?: bool

		// AllowHeaders defines the headers that are allowed to be sent
		// with requests.
		// It specifies the allowed headers in the
		// Access-Control-Allow-Headers CORS response header..
		// The value "*" allows any header to be sent.
		allowHeaders?: [...string]

		// AllowMethods defines the methods that are allowed to make
		// requests.
		// It specifies the allowed methods in the
		// Access-Control-Allow-Methods CORS response header..
		// The value "*" allows any method to be used.
		allowMethods?: [...string]

		// AllowOrigins defines the origins that are allowed to make
		// requests.
		// It specifies the allowed origins in the
		// Access-Control-Allow-Origin CORS response header.
		// The value "*" allows any origin to make requests.
		allowOrigins?: [...strings.MaxRunes(253) & strings.MinRunes(1) & =~"^(\\*|https?:\\/\\/(\\*|(\\*\\.)?(([\\w-]+\\.?)+)?[\\w-]+)(:\\d{1,5})?)$"]

		// ExposeHeaders defines which response headers should be made
		// accessible to
		// scripts running in the browser.
		// It specifies the headers in the Access-Control-Expose-Headers
		// CORS response header..
		// The value "*" allows any header to be exposed.
		exposeHeaders?: [...string]

		// MaxAge defines how long the results of a preflight request can
		// be cached.
		// It specifies the value in the Access-Control-Max-Age CORS
		// response header..
		maxAge?: string
	}

	// ExtAuth defines the configuration for External Authorization.
	extAuth?: {
		bodyToExtAuth?: {
			// MaxRequestBytes is the maximum size of a message body that the
			// filter will hold in memory.
			// Envoy will return HTTP 413 and will not initiate the
			// authorization process when buffer
			// reaches the number set in this field.
			// Note that this setting will have precedence over failOpen mode.
			maxRequestBytes!: int32 & >=1
		}

		// FailOpen is a switch used to control the behavior when a
		// response from the External Authorization service cannot be
		// obtained.
		// If FailOpen is set to true, the system allows the traffic to
		// pass through.
		// Otherwise, if it is set to false or not set (defaulting to
		// false),
		// the system blocks the traffic and returns a HTTP 5xx error,
		// reflecting a fail-closed approach.
		// This setting determines whether to prioritize accessibility
		// over strict security in case of authorization service failure.
		failOpen?: bool | *false

		// GRPC defines the gRPC External Authorization service.
		// Either GRPCService or HTTPService must be specified,
		// and only one of them can be provided.
		grpc?: {
			// BackendRef references a Kubernetes object that represents the
			// backend server to which the authorization request will be sent.
			//
			// Deprecated: Use BackendRefs instead.
			backendRef?: {
				// Group is the group of the referent. For example,
				// "gateway.networking.k8s.io".
				// When unspecified or empty string, core API group is inferred.
				group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

				// Kind is the Kubernetes resource kind of the referent. For
				// example
				// "Service".
				//
				// Defaults to "Service" when not specified.
				//
				// ExternalName services can refer to CNAME DNS records that may
				// live
				// outside of the cluster and as such are difficult to reason
				// about in
				// terms of conformance. They also may not be safe to forward to
				// (see
				// CVE-2021-25740 for more information). Implementations SHOULD
				// NOT
				// support ExternalName Services.
				//
				// Support: Core (Services with a type other than ExternalName)
				//
				// Support: Implementation-specific (Services with type
				// ExternalName)
				kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

				// Name is the name of the referent.
				name!: strings.MaxRunes(253) & strings.MinRunes(1)

				// Namespace is the namespace of the backend. When unspecified,
				// the local
				// namespace is inferred.
				//
				// Note that when a namespace different than the local namespace
				// is specified,
				// a ReferenceGrant object is required in the referent namespace
				// to allow that
				// namespace's owner to accept the reference. See the
				// ReferenceGrant
				// documentation for details.
				//
				// Support: Core
				namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
				}

				// Port specifies the destination port number to use for this
				// resource.
				// Port is required when the referent is a Kubernetes Service. In
				// this
				// case, the port number is the service port number, not the
				// target port.
				// For other resources, destination port might be derived from the
				// referent
				// resource or this field.
				port?: uint16 & >=1
			}

			// BackendRefs references a Kubernetes object that represents the
			// backend server to which the authorization request will be sent.
			backendRefs?: list.MaxItems(16) & [...{
				// Fallback indicates whether the backend is designated as a
				// fallback.
				// Multiple fallback backends can be configured.
				// It is highly recommended to configure active or passive health
				// checks to ensure that failover can be detected
				// when the active backends become unhealthy and to automatically
				// readjust once the primary backends are healthy again.
				// The overprovisioning factor is set to 1.4, meaning the fallback
				// backends will only start receiving traffic when
				// the health of the active backends falls below 72%.
				fallback?: bool

				// Group is the group of the referent. For example,
				// "gateway.networking.k8s.io".
				// When unspecified or empty string, core API group is inferred.
				group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

				// Kind is the Kubernetes resource kind of the referent. For
				// example
				// "Service".
				//
				// Defaults to "Service" when not specified.
				//
				// ExternalName services can refer to CNAME DNS records that may
				// live
				// outside of the cluster and as such are difficult to reason
				// about in
				// terms of conformance. They also may not be safe to forward to
				// (see
				// CVE-2021-25740 for more information). Implementations SHOULD
				// NOT
				// support ExternalName Services.
				//
				// Support: Core (Services with a type other than ExternalName)
				//
				// Support: Implementation-specific (Services with type
				// ExternalName)
				kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

				// Name is the name of the referent.
				name!: strings.MaxRunes(253) & strings.MinRunes(1)

				// Namespace is the namespace of the backend. When unspecified,
				// the local
				// namespace is inferred.
				//
				// Note that when a namespace different than the local namespace
				// is specified,
				// a ReferenceGrant object is required in the referent namespace
				// to allow that
				// namespace's owner to accept the reference. See the
				// ReferenceGrant
				// documentation for details.
				//
				// Support: Core
				namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
				}

				// Port specifies the destination port number to use for this
				// resource.
				// Port is required when the referent is a Kubernetes Service. In
				// this
				// case, the port number is the service port number, not the
				// target port.
				// For other resources, destination port might be derived from the
				// referent
				// resource or this field.
				port?: uint16 & >=1
			}]

			// BackendSettings holds configuration for managing the connection
			// to the backend.
			backendSettings?: {
				// Circuit Breaker settings for the upstream connections and
				// requests.
				// If not set, circuit breakers will be enabled with the default
				// thresholds
				circuitBreaker?: {
					// The maximum number of connections that Envoy will establish to
					// the referenced backend defined within a xRoute rule.
					maxConnections?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of parallel requests that Envoy will make to
					// the referenced backend defined within a xRoute rule.
					maxParallelRequests?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of parallel retries that Envoy will make to
					// the referenced backend defined within a xRoute rule.
					maxParallelRetries?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of pending requests that Envoy will queue to
					// the referenced backend defined within a xRoute rule.
					maxPendingRequests?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of requests that Envoy will make over a
					// single connection to the referenced backend defined within a
					// xRoute rule.
					// Default: unlimited.
					maxRequestsPerConnection?: uint32
				}

				// Connection includes backend connection settings.
				connection?: {
					// BufferLimit Soft limit on size of the cluster’s connections
					// read and write buffers.
					// BufferLimit applies to connection streaming (maybe
					// non-streaming) channel between processes, it's in user space.
					// If unspecified, an implementation defined default is applied
					// (32768 bytes).
					// For example, 20Mi, 1Gi, 256Ki etc.
					// Note: that when the suffix is not provided, the value is
					// interpreted as bytes.
					bufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

					// SocketBufferLimit provides configuration for the maximum buffer
					// size in bytes for each socket
					// to backend.
					// SocketBufferLimit applies to socket streaming channel between
					// TCP/IP stacks, it's in kernel space.
					// For example, 20Mi, 1Gi, 256Ki etc.
					// Note that when the suffix is not provided, the value is
					// interpreted as bytes.
					socketBufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])
				}

				// DNS includes dns resolution settings.
				dns?: {
					// DNSRefreshRate specifies the rate at which DNS records should
					// be refreshed.
					// Defaults to 30 seconds.
					dnsRefreshRate?: string

					// RespectDNSTTL indicates whether the DNS Time-To-Live (TTL)
					// should be respected.
					// If the value is set to true, the DNS refresh rate will be set
					// to the resource record’s TTL.
					// Defaults to true.
					respectDnsTtl?: bool
				}

				// HealthCheck allows gateway to perform active health checking on
				// backends.
				healthCheck?: {
					// Active health check configuration
					active?: {
						grpc?: {
							// Service to send in the health check request.
							// If this is not specified, then the health check request applies
							// to the entire
							// server and not to a specific service.
							service?: string
						}

						// HealthyThreshold defines the number of healthy health checks
						// required before a backend host is marked healthy.
						healthyThreshold?: int32 & int & >=1 | *1

						// HTTP defines the configuration of http health checker.
						// It's required while the health checker type is HTTP.
						http?: {
							// ExpectedResponse defines a list of HTTP expected responses to
							// match.
							expectedResponse?: {
								// Binary payload base64 encoded.
								binary?: string

								// Text payload in plain text.
								text?: string

								// Type defines the type of the payload.
								type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
							}

							// ExpectedStatuses defines a list of HTTP response statuses
							// considered healthy.
							// Defaults to 200 only
							expectedStatuses?: [...int & <600 & >=100]

							// Method defines the HTTP method used for health checking.
							// Defaults to GET
							method?: string

							// Path defines the HTTP path that will be requested during health
							// checking.
							path!: strings.MaxRunes(1024) & strings.MinRunes(1)
						}

						// Interval defines the time between active health checks.
						interval?: string | *"3s"

						// TCP defines the configuration of tcp health checker.
						// It's required while the health checker type is TCP.
						tcp?: {
							// Receive defines the expected response payload.
							receive?: {
								// Binary payload base64 encoded.
								binary?: string

								// Text payload in plain text.
								text?: string

								// Type defines the type of the payload.
								type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
							}

							// Send defines the request payload.
							send?: {
								// Binary payload base64 encoded.
								binary?: string

								// Text payload in plain text.
								text?: string

								// Type defines the type of the payload.
								type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
							}
						}

						// Timeout defines the time to wait for a health check response.
						timeout?: string | *"1s"

						// Type defines the type of health checker.
						type!: matchN(2, ["HTTP" | "TCP" | "GRPC", "HTTP" | "TCP" | "GRPC"])

						// UnhealthyThreshold defines the number of unhealthy health
						// checks required before a backend host is marked unhealthy.
						unhealthyThreshold?: int32 & int & >=1 | *3
					}

					// Passive passive check configuration
					passive?: {
						// BaseEjectionTime defines the base duration for which a host
						// will be ejected on consecutive failures.
						baseEjectionTime?: string | *"30s"

						// Consecutive5xxErrors sets the number of consecutive 5xx errors
						// triggering ejection.
						consecutive5XxErrors?: int32 & int | *5

						// ConsecutiveGatewayErrors sets the number of consecutive gateway
						// errors triggering ejection.
						consecutiveGatewayErrors?: int32 & int | *0

						// ConsecutiveLocalOriginFailures sets the number of consecutive
						// local origin failures triggering ejection.
						// Parameter takes effect only when
						// split_external_local_origin_errors is set to true.
						consecutiveLocalOriginFailures?: int32 & int | *5

						// Interval defines the time between passive health checks.
						interval?: string | *"3s"

						// MaxEjectionPercent sets the maximum percentage of hosts in a
						// cluster that can be ejected.
						maxEjectionPercent?: int32 & int | *10

						// SplitExternalLocalOriginErrors enables splitting of errors
						// between external and local origin.
						splitExternalLocalOriginErrors?: bool | *false
					}
				}

				// HTTP2 provides HTTP/2 configuration for backend connections.
				http2?: {
					// InitialConnectionWindowSize sets the initial window size for
					// HTTP/2 connections.
					// If not set, the default value is 1 MiB.
					initialConnectionWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

					// InitialStreamWindowSize sets the initial window size for HTTP/2
					// streams.
					// If not set, the default value is 64 KiB(64*1024).
					initialStreamWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

					// MaxConcurrentStreams sets the maximum number of concurrent
					// streams allowed per connection.
					// If not set, the default value is 100.
					maxConcurrentStreams?: int32 & >=1

					// OnInvalidMessage determines if Envoy will terminate the
					// connection or just the offending stream in the event of HTTP
					// messaging error
					// It's recommended for L2 Envoy deployments to set this value to
					// TerminateStream.
					// https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
					// Default: TerminateConnection
					onInvalidMessage?: string
				}

				// LoadBalancer policy to apply when routing traffic from the
				// gateway to
				// the backend endpoints. Defaults to `LeastRequest`.
				loadBalancer?: {
					// ConsistentHash defines the configuration when the load balancer
					// type is
					// set to ConsistentHash
					consistentHash?: {
						// Cookie configures the cookie hash policy when the consistent
						// hash type is set to Cookie.
						cookie?: {
							// Additional Attributes to set for the generated cookie.
							attributes?: close({
								[string]: string
							})

							// Name of the cookie to hash.
							// If this cookie does not exist in the request, Envoy will
							// generate a cookie and set
							// the TTL on the response back to the client based on Layer 4
							// attributes of the backend endpoint, to ensure that these future
							// requests
							// go to the same backend endpoint. Make sure to set the TTL field
							// for this case.
							name!: string

							// TTL of the generated cookie if the cookie is not present. This
							// value sets the
							// Max-Age attribute value.
							ttl?: string
						}
						header?: {
							// Name of the header to hash.
							name!: string
						}

						// The table size for consistent hashing, must be prime number
						// limited to 5000011.
						tableSize?: int64 & int & <=5000011 & >=2 | *65537

						// ConsistentHashType defines the type of input to hash on. Valid
						// Type values are
						// "SourceIP",
						// "Header",
						// "Cookie".
						type!: "SourceIP" | "Header" | "Cookie"
					}
					slowStart?: {
						// Window defines the duration of the warm up period for newly
						// added host.
						// During slow start window, traffic sent to the newly added hosts
						// will gradually increase.
						// Currently only supports linear growth of traffic. For
						// additional details,
						// see
						// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
						window!: string
					}

					// Type decides the type of Load Balancer policy.
					// Valid LoadBalancerType values are
					// "ConsistentHash",
					// "LeastRequest",
					// "Random",
					// "RoundRobin".
					type!: "ConsistentHash" | "LeastRequest" | "Random" | "RoundRobin"
				}
				proxyProtocol?: {
					// Version of ProxyProtol
					// Valid ProxyProtocolVersion values are
					// "V1"
					// "V2"
					version!: "V1" | "V2"
				}

				// Retry provides more advanced usage, allowing users to customize
				// the number of retries, retry fallback strategy, and retry
				// triggering conditions.
				// If not set, retry will be disabled.
				retry?: {
					// NumRetries is the number of retries to be attempted. Defaults
					// to 2.
					numRetries?: int32 & int & >=0 | *2

					// PerRetry is the retry policy to be applied per retry attempt.
					perRetry?: {
						// Backoff is the backoff policy to be applied per retry attempt.
						// gateway uses a fully jittered exponential
						// back-off algorithm for retries. For additional details,
						// see
						// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
						backOff?: {
							// BaseInterval is the base interval between retries.
							baseInterval?: string

							// MaxInterval is the maximum interval between retries. This
							// parameter is optional, but must be greater than or equal to
							// the base_interval if set.
							// The default is 10 times the base_interval
							maxInterval?: string
						}

						// Timeout is the timeout per retry attempt.
						timeout?: string
					}

					// RetryOn specifies the retry trigger condition.
					//
					// If not specified, the default is to retry on
					// connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
					retryOn?: {
						// HttpStatusCodes specifies the http status codes to be retried.
						// The retriable-status-codes trigger must also be configured for
						// these status codes to trigger a retry.
						httpStatusCodes?: [...int & <600 & >=100]

						// Triggers specifies the retry trigger condition(Http/Grpc).
						triggers?: [..."5xx" | "gateway-error" | "reset" | "connect-failure" | "retriable-4xx" | "refused-stream" | "retriable-status-codes" | "cancelled" | "deadline-exceeded" | "internal" | "resource-exhausted" | "unavailable"]
					}
				}

				// TcpKeepalive settings associated with the upstream client
				// connection.
				// Disabled by default.
				tcpKeepalive?: {
					// The duration a connection needs to be idle before keep-alive
					// probes start being sent.
					// The duration format is
					// Defaults to `7200s`.
					idleTime?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

					// The duration between keep-alive probes.
					// Defaults to `75s`.
					interval?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

					// The total number of unacknowledged probes to send before
					// deciding
					// the connection is dead.
					// Defaults to 9.
					probes?: int32
				}

				// Timeout settings for the backend connections.
				timeout?: {
					// Timeout settings for HTTP.
					http?: {
						// The idle timeout for an HTTP connection. Idle time is defined
						// as a period in which there are no active requests in the
						// connection.
						// Default: 1 hour.
						connectionIdleTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

						// The maximum duration of an HTTP connection.
						// Default: unlimited.
						maxConnectionDuration?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

						// RequestTimeout is the time until which entire response is
						// received from the upstream.
						requestTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
					}
					tcp?: {
						// The timeout for network connection establishment, including TCP
						// and TLS handshakes.
						// Default: 10 seconds.
						connectTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
					}
				}
			}
		}

		// HeadersToExtAuth defines the client request headers that will
		// be included
		// in the request to the external authorization service.
		// Note: If not specified, the default behavior for gRPC and HTTP
		// external
		// authorization services is different due to backward
		// compatibility reasons.
		// All headers will be included in the check request to a gRPC
		// authorization server.
		// Only the following headers will be included in the check
		// request to an HTTP
		// authorization server: Host, Method, Path, Content-Length, and
		// Authorization.
		// And these headers will always be included to the check request
		// to an HTTP
		// authorization server by default, no matter whether they are
		// specified
		// in HeadersToExtAuth or not.
		headersToExtAuth?: [...string]

		// HTTP defines the HTTP External Authorization service.
		// Either GRPCService or HTTPService must be specified,
		// and only one of them can be provided.
		http?: {
			// BackendRef references a Kubernetes object that represents the
			// backend server to which the authorization request will be sent.
			//
			// Deprecated: Use BackendRefs instead.
			backendRef?: {
				// Group is the group of the referent. For example,
				// "gateway.networking.k8s.io".
				// When unspecified or empty string, core API group is inferred.
				group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

				// Kind is the Kubernetes resource kind of the referent. For
				// example
				// "Service".
				//
				// Defaults to "Service" when not specified.
				//
				// ExternalName services can refer to CNAME DNS records that may
				// live
				// outside of the cluster and as such are difficult to reason
				// about in
				// terms of conformance. They also may not be safe to forward to
				// (see
				// CVE-2021-25740 for more information). Implementations SHOULD
				// NOT
				// support ExternalName Services.
				//
				// Support: Core (Services with a type other than ExternalName)
				//
				// Support: Implementation-specific (Services with type
				// ExternalName)
				kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

				// Name is the name of the referent.
				name!: strings.MaxRunes(253) & strings.MinRunes(1)

				// Namespace is the namespace of the backend. When unspecified,
				// the local
				// namespace is inferred.
				//
				// Note that when a namespace different than the local namespace
				// is specified,
				// a ReferenceGrant object is required in the referent namespace
				// to allow that
				// namespace's owner to accept the reference. See the
				// ReferenceGrant
				// documentation for details.
				//
				// Support: Core
				namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
				}

				// Port specifies the destination port number to use for this
				// resource.
				// Port is required when the referent is a Kubernetes Service. In
				// this
				// case, the port number is the service port number, not the
				// target port.
				// For other resources, destination port might be derived from the
				// referent
				// resource or this field.
				port?: uint16 & >=1
			}

			// BackendRefs references a Kubernetes object that represents the
			// backend server to which the authorization request will be sent.
			backendRefs?: list.MaxItems(16) & [...{
				// Fallback indicates whether the backend is designated as a
				// fallback.
				// Multiple fallback backends can be configured.
				// It is highly recommended to configure active or passive health
				// checks to ensure that failover can be detected
				// when the active backends become unhealthy and to automatically
				// readjust once the primary backends are healthy again.
				// The overprovisioning factor is set to 1.4, meaning the fallback
				// backends will only start receiving traffic when
				// the health of the active backends falls below 72%.
				fallback?: bool

				// Group is the group of the referent. For example,
				// "gateway.networking.k8s.io".
				// When unspecified or empty string, core API group is inferred.
				group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

				// Kind is the Kubernetes resource kind of the referent. For
				// example
				// "Service".
				//
				// Defaults to "Service" when not specified.
				//
				// ExternalName services can refer to CNAME DNS records that may
				// live
				// outside of the cluster and as such are difficult to reason
				// about in
				// terms of conformance. They also may not be safe to forward to
				// (see
				// CVE-2021-25740 for more information). Implementations SHOULD
				// NOT
				// support ExternalName Services.
				//
				// Support: Core (Services with a type other than ExternalName)
				//
				// Support: Implementation-specific (Services with type
				// ExternalName)
				kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

				// Name is the name of the referent.
				name!: strings.MaxRunes(253) & strings.MinRunes(1)

				// Namespace is the namespace of the backend. When unspecified,
				// the local
				// namespace is inferred.
				//
				// Note that when a namespace different than the local namespace
				// is specified,
				// a ReferenceGrant object is required in the referent namespace
				// to allow that
				// namespace's owner to accept the reference. See the
				// ReferenceGrant
				// documentation for details.
				//
				// Support: Core
				namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
				}

				// Port specifies the destination port number to use for this
				// resource.
				// Port is required when the referent is a Kubernetes Service. In
				// this
				// case, the port number is the service port number, not the
				// target port.
				// For other resources, destination port might be derived from the
				// referent
				// resource or this field.
				port?: uint16 & >=1
			}]

			// BackendSettings holds configuration for managing the connection
			// to the backend.
			backendSettings?: {
				// Circuit Breaker settings for the upstream connections and
				// requests.
				// If not set, circuit breakers will be enabled with the default
				// thresholds
				circuitBreaker?: {
					// The maximum number of connections that Envoy will establish to
					// the referenced backend defined within a xRoute rule.
					maxConnections?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of parallel requests that Envoy will make to
					// the referenced backend defined within a xRoute rule.
					maxParallelRequests?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of parallel retries that Envoy will make to
					// the referenced backend defined within a xRoute rule.
					maxParallelRetries?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of pending requests that Envoy will queue to
					// the referenced backend defined within a xRoute rule.
					maxPendingRequests?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of requests that Envoy will make over a
					// single connection to the referenced backend defined within a
					// xRoute rule.
					// Default: unlimited.
					maxRequestsPerConnection?: uint32
				}

				// Connection includes backend connection settings.
				connection?: {
					// BufferLimit Soft limit on size of the cluster’s connections
					// read and write buffers.
					// BufferLimit applies to connection streaming (maybe
					// non-streaming) channel between processes, it's in user space.
					// If unspecified, an implementation defined default is applied
					// (32768 bytes).
					// For example, 20Mi, 1Gi, 256Ki etc.
					// Note: that when the suffix is not provided, the value is
					// interpreted as bytes.
					bufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

					// SocketBufferLimit provides configuration for the maximum buffer
					// size in bytes for each socket
					// to backend.
					// SocketBufferLimit applies to socket streaming channel between
					// TCP/IP stacks, it's in kernel space.
					// For example, 20Mi, 1Gi, 256Ki etc.
					// Note that when the suffix is not provided, the value is
					// interpreted as bytes.
					socketBufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])
				}

				// DNS includes dns resolution settings.
				dns?: {
					// DNSRefreshRate specifies the rate at which DNS records should
					// be refreshed.
					// Defaults to 30 seconds.
					dnsRefreshRate?: string

					// RespectDNSTTL indicates whether the DNS Time-To-Live (TTL)
					// should be respected.
					// If the value is set to true, the DNS refresh rate will be set
					// to the resource record’s TTL.
					// Defaults to true.
					respectDnsTtl?: bool
				}

				// HealthCheck allows gateway to perform active health checking on
				// backends.
				healthCheck?: {
					// Active health check configuration
					active?: {
						grpc?: {
							// Service to send in the health check request.
							// If this is not specified, then the health check request applies
							// to the entire
							// server and not to a specific service.
							service?: string
						}

						// HealthyThreshold defines the number of healthy health checks
						// required before a backend host is marked healthy.
						healthyThreshold?: int32 & int & >=1 | *1

						// HTTP defines the configuration of http health checker.
						// It's required while the health checker type is HTTP.
						http?: {
							// ExpectedResponse defines a list of HTTP expected responses to
							// match.
							expectedResponse?: {
								// Binary payload base64 encoded.
								binary?: string

								// Text payload in plain text.
								text?: string

								// Type defines the type of the payload.
								type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
							}

							// ExpectedStatuses defines a list of HTTP response statuses
							// considered healthy.
							// Defaults to 200 only
							expectedStatuses?: [...int & <600 & >=100]

							// Method defines the HTTP method used for health checking.
							// Defaults to GET
							method?: string

							// Path defines the HTTP path that will be requested during health
							// checking.
							path!: strings.MaxRunes(1024) & strings.MinRunes(1)
						}

						// Interval defines the time between active health checks.
						interval?: string | *"3s"

						// TCP defines the configuration of tcp health checker.
						// It's required while the health checker type is TCP.
						tcp?: {
							// Receive defines the expected response payload.
							receive?: {
								// Binary payload base64 encoded.
								binary?: string

								// Text payload in plain text.
								text?: string

								// Type defines the type of the payload.
								type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
							}

							// Send defines the request payload.
							send?: {
								// Binary payload base64 encoded.
								binary?: string

								// Text payload in plain text.
								text?: string

								// Type defines the type of the payload.
								type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
							}
						}

						// Timeout defines the time to wait for a health check response.
						timeout?: string | *"1s"

						// Type defines the type of health checker.
						type!: matchN(2, ["HTTP" | "TCP" | "GRPC", "HTTP" | "TCP" | "GRPC"])

						// UnhealthyThreshold defines the number of unhealthy health
						// checks required before a backend host is marked unhealthy.
						unhealthyThreshold?: int32 & int & >=1 | *3
					}

					// Passive passive check configuration
					passive?: {
						// BaseEjectionTime defines the base duration for which a host
						// will be ejected on consecutive failures.
						baseEjectionTime?: string | *"30s"

						// Consecutive5xxErrors sets the number of consecutive 5xx errors
						// triggering ejection.
						consecutive5XxErrors?: int32 & int | *5

						// ConsecutiveGatewayErrors sets the number of consecutive gateway
						// errors triggering ejection.
						consecutiveGatewayErrors?: int32 & int | *0

						// ConsecutiveLocalOriginFailures sets the number of consecutive
						// local origin failures triggering ejection.
						// Parameter takes effect only when
						// split_external_local_origin_errors is set to true.
						consecutiveLocalOriginFailures?: int32 & int | *5

						// Interval defines the time between passive health checks.
						interval?: string | *"3s"

						// MaxEjectionPercent sets the maximum percentage of hosts in a
						// cluster that can be ejected.
						maxEjectionPercent?: int32 & int | *10

						// SplitExternalLocalOriginErrors enables splitting of errors
						// between external and local origin.
						splitExternalLocalOriginErrors?: bool | *false
					}
				}

				// HTTP2 provides HTTP/2 configuration for backend connections.
				http2?: {
					// InitialConnectionWindowSize sets the initial window size for
					// HTTP/2 connections.
					// If not set, the default value is 1 MiB.
					initialConnectionWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

					// InitialStreamWindowSize sets the initial window size for HTTP/2
					// streams.
					// If not set, the default value is 64 KiB(64*1024).
					initialStreamWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

					// MaxConcurrentStreams sets the maximum number of concurrent
					// streams allowed per connection.
					// If not set, the default value is 100.
					maxConcurrentStreams?: int32 & >=1

					// OnInvalidMessage determines if Envoy will terminate the
					// connection or just the offending stream in the event of HTTP
					// messaging error
					// It's recommended for L2 Envoy deployments to set this value to
					// TerminateStream.
					// https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
					// Default: TerminateConnection
					onInvalidMessage?: string
				}

				// LoadBalancer policy to apply when routing traffic from the
				// gateway to
				// the backend endpoints. Defaults to `LeastRequest`.
				loadBalancer?: {
					// ConsistentHash defines the configuration when the load balancer
					// type is
					// set to ConsistentHash
					consistentHash?: {
						// Cookie configures the cookie hash policy when the consistent
						// hash type is set to Cookie.
						cookie?: {
							// Additional Attributes to set for the generated cookie.
							attributes?: close({
								[string]: string
							})

							// Name of the cookie to hash.
							// If this cookie does not exist in the request, Envoy will
							// generate a cookie and set
							// the TTL on the response back to the client based on Layer 4
							// attributes of the backend endpoint, to ensure that these future
							// requests
							// go to the same backend endpoint. Make sure to set the TTL field
							// for this case.
							name!: string

							// TTL of the generated cookie if the cookie is not present. This
							// value sets the
							// Max-Age attribute value.
							ttl?: string
						}
						header?: {
							// Name of the header to hash.
							name!: string
						}

						// The table size for consistent hashing, must be prime number
						// limited to 5000011.
						tableSize?: int64 & int & <=5000011 & >=2 | *65537

						// ConsistentHashType defines the type of input to hash on. Valid
						// Type values are
						// "SourceIP",
						// "Header",
						// "Cookie".
						type!: "SourceIP" | "Header" | "Cookie"
					}
					slowStart?: {
						// Window defines the duration of the warm up period for newly
						// added host.
						// During slow start window, traffic sent to the newly added hosts
						// will gradually increase.
						// Currently only supports linear growth of traffic. For
						// additional details,
						// see
						// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
						window!: string
					}

					// Type decides the type of Load Balancer policy.
					// Valid LoadBalancerType values are
					// "ConsistentHash",
					// "LeastRequest",
					// "Random",
					// "RoundRobin".
					type!: "ConsistentHash" | "LeastRequest" | "Random" | "RoundRobin"
				}
				proxyProtocol?: {
					// Version of ProxyProtol
					// Valid ProxyProtocolVersion values are
					// "V1"
					// "V2"
					version!: "V1" | "V2"
				}

				// Retry provides more advanced usage, allowing users to customize
				// the number of retries, retry fallback strategy, and retry
				// triggering conditions.
				// If not set, retry will be disabled.
				retry?: {
					// NumRetries is the number of retries to be attempted. Defaults
					// to 2.
					numRetries?: int32 & int & >=0 | *2

					// PerRetry is the retry policy to be applied per retry attempt.
					perRetry?: {
						// Backoff is the backoff policy to be applied per retry attempt.
						// gateway uses a fully jittered exponential
						// back-off algorithm for retries. For additional details,
						// see
						// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
						backOff?: {
							// BaseInterval is the base interval between retries.
							baseInterval?: string

							// MaxInterval is the maximum interval between retries. This
							// parameter is optional, but must be greater than or equal to
							// the base_interval if set.
							// The default is 10 times the base_interval
							maxInterval?: string
						}

						// Timeout is the timeout per retry attempt.
						timeout?: string
					}

					// RetryOn specifies the retry trigger condition.
					//
					// If not specified, the default is to retry on
					// connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
					retryOn?: {
						// HttpStatusCodes specifies the http status codes to be retried.
						// The retriable-status-codes trigger must also be configured for
						// these status codes to trigger a retry.
						httpStatusCodes?: [...int & <600 & >=100]

						// Triggers specifies the retry trigger condition(Http/Grpc).
						triggers?: [..."5xx" | "gateway-error" | "reset" | "connect-failure" | "retriable-4xx" | "refused-stream" | "retriable-status-codes" | "cancelled" | "deadline-exceeded" | "internal" | "resource-exhausted" | "unavailable"]
					}
				}

				// TcpKeepalive settings associated with the upstream client
				// connection.
				// Disabled by default.
				tcpKeepalive?: {
					// The duration a connection needs to be idle before keep-alive
					// probes start being sent.
					// The duration format is
					// Defaults to `7200s`.
					idleTime?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

					// The duration between keep-alive probes.
					// Defaults to `75s`.
					interval?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

					// The total number of unacknowledged probes to send before
					// deciding
					// the connection is dead.
					// Defaults to 9.
					probes?: int32
				}

				// Timeout settings for the backend connections.
				timeout?: {
					// Timeout settings for HTTP.
					http?: {
						// The idle timeout for an HTTP connection. Idle time is defined
						// as a period in which there are no active requests in the
						// connection.
						// Default: 1 hour.
						connectionIdleTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

						// The maximum duration of an HTTP connection.
						// Default: unlimited.
						maxConnectionDuration?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

						// RequestTimeout is the time until which entire response is
						// received from the upstream.
						requestTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
					}
					tcp?: {
						// The timeout for network connection establishment, including TCP
						// and TLS handshakes.
						// Default: 10 seconds.
						connectTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
					}
				}
			}

			// HeadersToBackend are the authorization response headers that
			// will be added
			// to the original client request before sending it to the backend
			// server.
			// Note that coexisting headers will be overridden.
			// If not specified, no authorization response headers will be
			// added to the
			// original client request.
			headersToBackend?: [...string]

			// Path is the path of the HTTP External Authorization service.
			// If path is specified, the authorization request will be sent to
			// that path,
			// or else the authorization request will be sent to the root
			// path.
			path?: string
		}

		// RecomputeRoute clears the route cache and recalculates the
		// routing decision.
		// This field must be enabled if the headers added or modified by
		// the ExtAuth are used for
		// route matching decisions. If the recomputation selects a new
		// route, features targeting
		// the new matched route will be applied.
		recomputeRoute?: bool
	}

	// JWT defines the configuration for JSON Web Token (JWT)
	// authentication.
	jwt?: {
		// Optional determines whether a missing JWT is acceptable,
		// defaulting to false if not specified.
		// Note: Even if optional is set to true, JWT authentication will
		// still fail if an invalid JWT is presented.
		optional?: bool

		// Providers defines the JSON Web Token (JWT) authentication
		// provider type.
		// When multiple JWT providers are specified, the JWT is
		// considered valid if
		// any of the providers successfully validate the JWT. For
		// additional details,
		// see
		// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/jwt_authn_filter.html.
		providers!: list.MaxItems(4) & [...{
			// Audiences is a list of JWT audiences allowed access. For
			// additional details, see
			// https://tools.ietf.org/html/rfc7519#section-4.1.3. If not
			// provided, JWT audiences
			// are not checked.
			audiences?: list.MaxItems(8) & [...string]

			// ClaimToHeaders is a list of JWT claims that must be extracted
			// into HTTP request headers
			// For examples, following config:
			// The claim must be of type; string, int, double, bool. Array
			// type claims are not supported
			claimToHeaders?: [...{
				// Claim is the JWT Claim that should be saved into the header :
				// it can be a nested claim of type
				// (eg. "claim.nested.key", "sub"). The nested claim name must use
				// dot "."
				// to separate the JSON name path.
				claim!: string

				// Header defines the name of the HTTP request header that the JWT
				// Claim will be saved into.
				header!: string
			}]

			// ExtractFrom defines different ways to extract the JWT token
			// from HTTP request.
			// If empty, it defaults to extract JWT token from the
			// Authorization HTTP request header using Bearer schema
			// or access_token from query parameters.
			extractFrom?: {
				// Cookies represents a list of cookie names to extract the JWT
				// token from.
				cookies?: [...string]

				// Headers represents a list of HTTP request headers to extract
				// the JWT token from.
				headers?: [...{
					// Name is the HTTP header name to retrieve the token
					name!: string

					// ValuePrefix is the prefix that should be stripped before
					// extracting the token.
					// The format would be used by Envoy like "{ValuePrefix}<TOKEN>".
					// For example, "Authorization: Bearer <TOKEN>", then the
					// ValuePrefix="Bearer " with a space at the end.
					valuePrefix?: string
				}]

				// Params represents a list of query parameters to extract the JWT
				// token from.
				params?: [...string]
			}

			// Issuer is the principal that issued the JWT and takes the form
			// of a URL or email address.
			// For additional details, see
			// https://tools.ietf.org/html/rfc7519#section-4.1.1 for
			// URL format and https://rfc-editor.org/rfc/rfc5322.html for
			// email format. If not provided,
			// the JWT issuer is not checked.
			issuer?: strings.MaxRunes(253)

			// Name defines a unique name for the JWT provider. A name can
			// have a variety of forms,
			// including RFC1123 subdomains, RFC 1123 labels, or RFC 1035
			// labels.
			name!: strings.MaxRunes(253) & strings.MinRunes(1)

			// RecomputeRoute clears the route cache and recalculates the
			// routing decision.
			// This field must be enabled if the headers generated from the
			// claim are used for
			// route matching decisions. If the recomputation selects a new
			// route, features targeting
			// the new matched route will be applied.
			recomputeRoute?: bool

			// RemoteJWKS defines how to fetch and cache JSON Web Key Sets
			// (JWKS) from a remote
			// HTTP/HTTPS endpoint.
			remoteJWKS!: {
				// BackendRef references a Kubernetes object that represents the
				// backend server to which the authorization request will be sent.
				//
				// Deprecated: Use BackendRefs instead.
				backendRef?: {
					// Group is the group of the referent. For example,
					// "gateway.networking.k8s.io".
					// When unspecified or empty string, core API group is inferred.
					group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

					// Kind is the Kubernetes resource kind of the referent. For
					// example
					// "Service".
					//
					// Defaults to "Service" when not specified.
					//
					// ExternalName services can refer to CNAME DNS records that may
					// live
					// outside of the cluster and as such are difficult to reason
					// about in
					// terms of conformance. They also may not be safe to forward to
					// (see
					// CVE-2021-25740 for more information). Implementations SHOULD
					// NOT
					// support ExternalName Services.
					//
					// Support: Core (Services with a type other than ExternalName)
					//
					// Support: Implementation-specific (Services with type
					// ExternalName)
					kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

					// Name is the name of the referent.
					name!: strings.MaxRunes(253) & strings.MinRunes(1)

					// Namespace is the namespace of the backend. When unspecified,
					// the local
					// namespace is inferred.
					//
					// Note that when a namespace different than the local namespace
					// is specified,
					// a ReferenceGrant object is required in the referent namespace
					// to allow that
					// namespace's owner to accept the reference. See the
					// ReferenceGrant
					// documentation for details.
					//
					// Support: Core
					namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
					}

					// Port specifies the destination port number to use for this
					// resource.
					// Port is required when the referent is a Kubernetes Service. In
					// this
					// case, the port number is the service port number, not the
					// target port.
					// For other resources, destination port might be derived from the
					// referent
					// resource or this field.
					port?: uint16 & >=1
				}

				// BackendRefs references a Kubernetes object that represents the
				// backend server to which the authorization request will be sent.
				backendRefs?: list.MaxItems(16) & [...{
					// Fallback indicates whether the backend is designated as a
					// fallback.
					// Multiple fallback backends can be configured.
					// It is highly recommended to configure active or passive health
					// checks to ensure that failover can be detected
					// when the active backends become unhealthy and to automatically
					// readjust once the primary backends are healthy again.
					// The overprovisioning factor is set to 1.4, meaning the fallback
					// backends will only start receiving traffic when
					// the health of the active backends falls below 72%.
					fallback?: bool

					// Group is the group of the referent. For example,
					// "gateway.networking.k8s.io".
					// When unspecified or empty string, core API group is inferred.
					group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

					// Kind is the Kubernetes resource kind of the referent. For
					// example
					// "Service".
					//
					// Defaults to "Service" when not specified.
					//
					// ExternalName services can refer to CNAME DNS records that may
					// live
					// outside of the cluster and as such are difficult to reason
					// about in
					// terms of conformance. They also may not be safe to forward to
					// (see
					// CVE-2021-25740 for more information). Implementations SHOULD
					// NOT
					// support ExternalName Services.
					//
					// Support: Core (Services with a type other than ExternalName)
					//
					// Support: Implementation-specific (Services with type
					// ExternalName)
					kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

					// Name is the name of the referent.
					name!: strings.MaxRunes(253) & strings.MinRunes(1)

					// Namespace is the namespace of the backend. When unspecified,
					// the local
					// namespace is inferred.
					//
					// Note that when a namespace different than the local namespace
					// is specified,
					// a ReferenceGrant object is required in the referent namespace
					// to allow that
					// namespace's owner to accept the reference. See the
					// ReferenceGrant
					// documentation for details.
					//
					// Support: Core
					namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
					}

					// Port specifies the destination port number to use for this
					// resource.
					// Port is required when the referent is a Kubernetes Service. In
					// this
					// case, the port number is the service port number, not the
					// target port.
					// For other resources, destination port might be derived from the
					// referent
					// resource or this field.
					port?: uint16 & >=1
				}]

				// BackendSettings holds configuration for managing the connection
				// to the backend.
				backendSettings?: {
					// Circuit Breaker settings for the upstream connections and
					// requests.
					// If not set, circuit breakers will be enabled with the default
					// thresholds
					circuitBreaker?: {
						// The maximum number of connections that Envoy will establish to
						// the referenced backend defined within a xRoute rule.
						maxConnections?: int64 & int & <=4294967295 & >=0 | *1024

						// The maximum number of parallel requests that Envoy will make to
						// the referenced backend defined within a xRoute rule.
						maxParallelRequests?: int64 & int & <=4294967295 & >=0 | *1024

						// The maximum number of parallel retries that Envoy will make to
						// the referenced backend defined within a xRoute rule.
						maxParallelRetries?: int64 & int & <=4294967295 & >=0 | *1024

						// The maximum number of pending requests that Envoy will queue to
						// the referenced backend defined within a xRoute rule.
						maxPendingRequests?: int64 & int & <=4294967295 & >=0 | *1024

						// The maximum number of requests that Envoy will make over a
						// single connection to the referenced backend defined within a
						// xRoute rule.
						// Default: unlimited.
						maxRequestsPerConnection?: uint32
					}

					// Connection includes backend connection settings.
					connection?: {
						// BufferLimit Soft limit on size of the cluster’s connections
						// read and write buffers.
						// BufferLimit applies to connection streaming (maybe
						// non-streaming) channel between processes, it's in user space.
						// If unspecified, an implementation defined default is applied
						// (32768 bytes).
						// For example, 20Mi, 1Gi, 256Ki etc.
						// Note: that when the suffix is not provided, the value is
						// interpreted as bytes.
						bufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

						// SocketBufferLimit provides configuration for the maximum buffer
						// size in bytes for each socket
						// to backend.
						// SocketBufferLimit applies to socket streaming channel between
						// TCP/IP stacks, it's in kernel space.
						// For example, 20Mi, 1Gi, 256Ki etc.
						// Note that when the suffix is not provided, the value is
						// interpreted as bytes.
						socketBufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])
					}

					// DNS includes dns resolution settings.
					dns?: {
						// DNSRefreshRate specifies the rate at which DNS records should
						// be refreshed.
						// Defaults to 30 seconds.
						dnsRefreshRate?: string

						// RespectDNSTTL indicates whether the DNS Time-To-Live (TTL)
						// should be respected.
						// If the value is set to true, the DNS refresh rate will be set
						// to the resource record’s TTL.
						// Defaults to true.
						respectDnsTtl?: bool
					}

					// HealthCheck allows gateway to perform active health checking on
					// backends.
					healthCheck?: {
						// Active health check configuration
						active?: {
							grpc?: {
								// Service to send in the health check request.
								// If this is not specified, then the health check request applies
								// to the entire
								// server and not to a specific service.
								service?: string
							}

							// HealthyThreshold defines the number of healthy health checks
							// required before a backend host is marked healthy.
							healthyThreshold?: int32 & int & >=1 | *1

							// HTTP defines the configuration of http health checker.
							// It's required while the health checker type is HTTP.
							http?: {
								// ExpectedResponse defines a list of HTTP expected responses to
								// match.
								expectedResponse?: {
									// Binary payload base64 encoded.
									binary?: string

									// Text payload in plain text.
									text?: string

									// Type defines the type of the payload.
									type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
								}

								// ExpectedStatuses defines a list of HTTP response statuses
								// considered healthy.
								// Defaults to 200 only
								expectedStatuses?: [...int & <600 & >=100]

								// Method defines the HTTP method used for health checking.
								// Defaults to GET
								method?: string

								// Path defines the HTTP path that will be requested during health
								// checking.
								path!: strings.MaxRunes(1024) & strings.MinRunes(1)
							}

							// Interval defines the time between active health checks.
							interval?: string | *"3s"

							// TCP defines the configuration of tcp health checker.
							// It's required while the health checker type is TCP.
							tcp?: {
								// Receive defines the expected response payload.
								receive?: {
									// Binary payload base64 encoded.
									binary?: string

									// Text payload in plain text.
									text?: string

									// Type defines the type of the payload.
									type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
								}

								// Send defines the request payload.
								send?: {
									// Binary payload base64 encoded.
									binary?: string

									// Text payload in plain text.
									text?: string

									// Type defines the type of the payload.
									type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
								}
							}

							// Timeout defines the time to wait for a health check response.
							timeout?: string | *"1s"

							// Type defines the type of health checker.
							type!: matchN(2, ["HTTP" | "TCP" | "GRPC", "HTTP" | "TCP" | "GRPC"])

							// UnhealthyThreshold defines the number of unhealthy health
							// checks required before a backend host is marked unhealthy.
							unhealthyThreshold?: int32 & int & >=1 | *3
						}

						// Passive passive check configuration
						passive?: {
							// BaseEjectionTime defines the base duration for which a host
							// will be ejected on consecutive failures.
							baseEjectionTime?: string | *"30s"

							// Consecutive5xxErrors sets the number of consecutive 5xx errors
							// triggering ejection.
							consecutive5XxErrors?: int32 & int | *5

							// ConsecutiveGatewayErrors sets the number of consecutive gateway
							// errors triggering ejection.
							consecutiveGatewayErrors?: int32 & int | *0

							// ConsecutiveLocalOriginFailures sets the number of consecutive
							// local origin failures triggering ejection.
							// Parameter takes effect only when
							// split_external_local_origin_errors is set to true.
							consecutiveLocalOriginFailures?: int32 & int | *5

							// Interval defines the time between passive health checks.
							interval?: string | *"3s"

							// MaxEjectionPercent sets the maximum percentage of hosts in a
							// cluster that can be ejected.
							maxEjectionPercent?: int32 & int | *10

							// SplitExternalLocalOriginErrors enables splitting of errors
							// between external and local origin.
							splitExternalLocalOriginErrors?: bool | *false
						}
					}

					// HTTP2 provides HTTP/2 configuration for backend connections.
					http2?: {
						// InitialConnectionWindowSize sets the initial window size for
						// HTTP/2 connections.
						// If not set, the default value is 1 MiB.
						initialConnectionWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

						// InitialStreamWindowSize sets the initial window size for HTTP/2
						// streams.
						// If not set, the default value is 64 KiB(64*1024).
						initialStreamWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

						// MaxConcurrentStreams sets the maximum number of concurrent
						// streams allowed per connection.
						// If not set, the default value is 100.
						maxConcurrentStreams?: int32 & >=1

						// OnInvalidMessage determines if Envoy will terminate the
						// connection or just the offending stream in the event of HTTP
						// messaging error
						// It's recommended for L2 Envoy deployments to set this value to
						// TerminateStream.
						// https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
						// Default: TerminateConnection
						onInvalidMessage?: string
					}

					// LoadBalancer policy to apply when routing traffic from the
					// gateway to
					// the backend endpoints. Defaults to `LeastRequest`.
					loadBalancer?: {
						// ConsistentHash defines the configuration when the load balancer
						// type is
						// set to ConsistentHash
						consistentHash?: {
							// Cookie configures the cookie hash policy when the consistent
							// hash type is set to Cookie.
							cookie?: {
								// Additional Attributes to set for the generated cookie.
								attributes?: close({
									[string]: string
								})

								// Name of the cookie to hash.
								// If this cookie does not exist in the request, Envoy will
								// generate a cookie and set
								// the TTL on the response back to the client based on Layer 4
								// attributes of the backend endpoint, to ensure that these future
								// requests
								// go to the same backend endpoint. Make sure to set the TTL field
								// for this case.
								name!: string

								// TTL of the generated cookie if the cookie is not present. This
								// value sets the
								// Max-Age attribute value.
								ttl?: string
							}
							header?: {
								// Name of the header to hash.
								name!: string
							}

							// The table size for consistent hashing, must be prime number
							// limited to 5000011.
							tableSize?: int64 & int & <=5000011 & >=2 | *65537

							// ConsistentHashType defines the type of input to hash on. Valid
							// Type values are
							// "SourceIP",
							// "Header",
							// "Cookie".
							type!: "SourceIP" | "Header" | "Cookie"
						}
						slowStart?: {
							// Window defines the duration of the warm up period for newly
							// added host.
							// During slow start window, traffic sent to the newly added hosts
							// will gradually increase.
							// Currently only supports linear growth of traffic. For
							// additional details,
							// see
							// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
							window!: string
						}

						// Type decides the type of Load Balancer policy.
						// Valid LoadBalancerType values are
						// "ConsistentHash",
						// "LeastRequest",
						// "Random",
						// "RoundRobin".
						type!: "ConsistentHash" | "LeastRequest" | "Random" | "RoundRobin"
					}
					proxyProtocol?: {
						// Version of ProxyProtol
						// Valid ProxyProtocolVersion values are
						// "V1"
						// "V2"
						version!: "V1" | "V2"
					}

					// Retry provides more advanced usage, allowing users to customize
					// the number of retries, retry fallback strategy, and retry
					// triggering conditions.
					// If not set, retry will be disabled.
					retry?: {
						// NumRetries is the number of retries to be attempted. Defaults
						// to 2.
						numRetries?: int32 & int & >=0 | *2

						// PerRetry is the retry policy to be applied per retry attempt.
						perRetry?: {
							// Backoff is the backoff policy to be applied per retry attempt.
							// gateway uses a fully jittered exponential
							// back-off algorithm for retries. For additional details,
							// see
							// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
							backOff?: {
								// BaseInterval is the base interval between retries.
								baseInterval?: string

								// MaxInterval is the maximum interval between retries. This
								// parameter is optional, but must be greater than or equal to
								// the base_interval if set.
								// The default is 10 times the base_interval
								maxInterval?: string
							}

							// Timeout is the timeout per retry attempt.
							timeout?: string
						}

						// RetryOn specifies the retry trigger condition.
						//
						// If not specified, the default is to retry on
						// connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
						retryOn?: {
							// HttpStatusCodes specifies the http status codes to be retried.
							// The retriable-status-codes trigger must also be configured for
							// these status codes to trigger a retry.
							httpStatusCodes?: [...int & <600 & >=100]

							// Triggers specifies the retry trigger condition(Http/Grpc).
							triggers?: [..."5xx" | "gateway-error" | "reset" | "connect-failure" | "retriable-4xx" | "refused-stream" | "retriable-status-codes" | "cancelled" | "deadline-exceeded" | "internal" | "resource-exhausted" | "unavailable"]
						}
					}

					// TcpKeepalive settings associated with the upstream client
					// connection.
					// Disabled by default.
					tcpKeepalive?: {
						// The duration a connection needs to be idle before keep-alive
						// probes start being sent.
						// The duration format is
						// Defaults to `7200s`.
						idleTime?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

						// The duration between keep-alive probes.
						// Defaults to `75s`.
						interval?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

						// The total number of unacknowledged probes to send before
						// deciding
						// the connection is dead.
						// Defaults to 9.
						probes?: int32
					}

					// Timeout settings for the backend connections.
					timeout?: {
						// Timeout settings for HTTP.
						http?: {
							// The idle timeout for an HTTP connection. Idle time is defined
							// as a period in which there are no active requests in the
							// connection.
							// Default: 1 hour.
							connectionIdleTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

							// The maximum duration of an HTTP connection.
							// Default: unlimited.
							maxConnectionDuration?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

							// RequestTimeout is the time until which entire response is
							// received from the upstream.
							requestTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
						}
						tcp?: {
							// The timeout for network connection establishment, including TCP
							// and TLS handshakes.
							// Default: 10 seconds.
							connectTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
						}
					}
				}

				// URI is the HTTPS URI to fetch the JWKS. Envoy's system trust
				// bundle is used to validate the server certificate.
				// If a custom trust bundle is needed, it can be specified in a
				// BackendTLSConfig resource and target the BackendRefs.
				uri!: strings.MaxRunes(253) & strings.MinRunes(1)
			}
		}] & [_, ...]
	}

	// OIDC defines the configuration for the OpenID Connect (OIDC)
	// authentication.
	oidc?: {
		// The client ID to be used in the OIDC
		// [Authentication
		// Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
		clientID!: strings.MinRunes(1)

		// The Kubernetes secret which contains the OIDC client secret to
		// be used in the
		// [Authentication
		// Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
		//
		// This is an Opaque secret. The client secret should be stored in
		// the key
		// "client-secret".
		clientSecret!: {
			// Group is the group of the referent. For example,
			// "gateway.networking.k8s.io".
			// When unspecified or empty string, core API group is inferred.
			group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

			// Kind is kind of the referent. For example "Secret".
			kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Secret"

			// Name is the name of the referent.
			name!: strings.MaxRunes(253) & strings.MinRunes(1)

			// Namespace is the namespace of the referenced object. When
			// unspecified, the local
			// namespace is inferred.
			//
			// Note that when a namespace different than the local namespace
			// is specified,
			// a ReferenceGrant object is required in the referent namespace
			// to allow that
			// namespace's owner to accept the reference. See the
			// ReferenceGrant
			// documentation for details.
			//
			// Support: Core
			namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
			}
		}

		// The optional domain to set the access and ID token cookies on.
		// If not set, the cookies will default to the host of the
		// request, not including the subdomains.
		// If set, the cookies will be set on the specified domain and all
		// subdomains.
		// This means that requests to any subdomain will not require
		// reauthentication after users log in to the parent domain.
		cookieDomain?: =~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9]))*$"

		// The optional cookie name overrides to be used for Bearer and
		// IdToken cookies in the
		// [Authentication
		// Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
		// If not specified, uses a randomly generated suffix
		cookieNames?: {
			// The name of the cookie used to store the AccessToken in the
			// [Authentication
			// Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
			// If not specified, defaults to "AccessToken-(randomly generated
			// uid)"
			accessToken?: string

			// The name of the cookie used to store the IdToken in the
			// [Authentication
			// Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
			// If not specified, defaults to "IdToken-(randomly generated
			// uid)"
			idToken?: string
		}

		// DefaultRefreshTokenTTL is the default lifetime of the refresh
		// token.
		// This field is only used when the exp (expiration time) claim is
		// omitted in
		// the refresh token or the refresh token is not JWT.
		//
		// If not specified, defaults to 604800s (one week).
		// Note: this field is only applicable when the "refreshToken"
		// field is set to true.
		defaultRefreshTokenTTL?: string

		// DefaultTokenTTL is the default lifetime of the id token and
		// access token.
		// Please note that Envoy will always use the expiry time from the
		// response
		// of the authorization server if it is provided. This field is
		// only used when
		// the expiry time is not provided by the authorization.
		//
		// If not specified, defaults to 0. In this case, the "expires_in"
		// field in
		// the authorization response must be set by the authorization
		// server, or the
		// OAuth flow will fail.
		defaultTokenTTL?: string

		// ForwardAccessToken indicates whether the Envoy should forward
		// the access token
		// via the Authorization header Bearer scheme to the upstream.
		// If not specified, defaults to false.
		forwardAccessToken?: bool

		// The path to log a user out, clearing their credential cookies.
		//
		// If not specified, uses a default logout path "/logout"
		logoutPath?: string

		// The OIDC Provider configuration.
		provider!: {
			// The OIDC Provider's [authorization
			// endpoint](https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint).
			// If not provided, EG will try to discover it from the provider's
			// [Well-Known Configuration
			// Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
			authorizationEndpoint?: string

			// BackendRef references a Kubernetes object that represents the
			// backend server to which the authorization request will be sent.
			//
			// Deprecated: Use BackendRefs instead.
			backendRef?: {
				// Group is the group of the referent. For example,
				// "gateway.networking.k8s.io".
				// When unspecified or empty string, core API group is inferred.
				group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

				// Kind is the Kubernetes resource kind of the referent. For
				// example
				// "Service".
				//
				// Defaults to "Service" when not specified.
				//
				// ExternalName services can refer to CNAME DNS records that may
				// live
				// outside of the cluster and as such are difficult to reason
				// about in
				// terms of conformance. They also may not be safe to forward to
				// (see
				// CVE-2021-25740 for more information). Implementations SHOULD
				// NOT
				// support ExternalName Services.
				//
				// Support: Core (Services with a type other than ExternalName)
				//
				// Support: Implementation-specific (Services with type
				// ExternalName)
				kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

				// Name is the name of the referent.
				name!: strings.MaxRunes(253) & strings.MinRunes(1)

				// Namespace is the namespace of the backend. When unspecified,
				// the local
				// namespace is inferred.
				//
				// Note that when a namespace different than the local namespace
				// is specified,
				// a ReferenceGrant object is required in the referent namespace
				// to allow that
				// namespace's owner to accept the reference. See the
				// ReferenceGrant
				// documentation for details.
				//
				// Support: Core
				namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
				}

				// Port specifies the destination port number to use for this
				// resource.
				// Port is required when the referent is a Kubernetes Service. In
				// this
				// case, the port number is the service port number, not the
				// target port.
				// For other resources, destination port might be derived from the
				// referent
				// resource or this field.
				port?: uint16 & >=1
			}

			// BackendRefs references a Kubernetes object that represents the
			// backend server to which the authorization request will be sent.
			backendRefs?: list.MaxItems(16) & [...{
				// Fallback indicates whether the backend is designated as a
				// fallback.
				// Multiple fallback backends can be configured.
				// It is highly recommended to configure active or passive health
				// checks to ensure that failover can be detected
				// when the active backends become unhealthy and to automatically
				// readjust once the primary backends are healthy again.
				// The overprovisioning factor is set to 1.4, meaning the fallback
				// backends will only start receiving traffic when
				// the health of the active backends falls below 72%.
				fallback?: bool

				// Group is the group of the referent. For example,
				// "gateway.networking.k8s.io".
				// When unspecified or empty string, core API group is inferred.
				group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

				// Kind is the Kubernetes resource kind of the referent. For
				// example
				// "Service".
				//
				// Defaults to "Service" when not specified.
				//
				// ExternalName services can refer to CNAME DNS records that may
				// live
				// outside of the cluster and as such are difficult to reason
				// about in
				// terms of conformance. They also may not be safe to forward to
				// (see
				// CVE-2021-25740 for more information). Implementations SHOULD
				// NOT
				// support ExternalName Services.
				//
				// Support: Core (Services with a type other than ExternalName)
				//
				// Support: Implementation-specific (Services with type
				// ExternalName)
				kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

				// Name is the name of the referent.
				name!: strings.MaxRunes(253) & strings.MinRunes(1)

				// Namespace is the namespace of the backend. When unspecified,
				// the local
				// namespace is inferred.
				//
				// Note that when a namespace different than the local namespace
				// is specified,
				// a ReferenceGrant object is required in the referent namespace
				// to allow that
				// namespace's owner to accept the reference. See the
				// ReferenceGrant
				// documentation for details.
				//
				// Support: Core
				namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
				}

				// Port specifies the destination port number to use for this
				// resource.
				// Port is required when the referent is a Kubernetes Service. In
				// this
				// case, the port number is the service port number, not the
				// target port.
				// For other resources, destination port might be derived from the
				// referent
				// resource or this field.
				port?: uint16 & >=1
			}]

			// BackendSettings holds configuration for managing the connection
			// to the backend.
			backendSettings?: {
				// Circuit Breaker settings for the upstream connections and
				// requests.
				// If not set, circuit breakers will be enabled with the default
				// thresholds
				circuitBreaker?: {
					// The maximum number of connections that Envoy will establish to
					// the referenced backend defined within a xRoute rule.
					maxConnections?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of parallel requests that Envoy will make to
					// the referenced backend defined within a xRoute rule.
					maxParallelRequests?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of parallel retries that Envoy will make to
					// the referenced backend defined within a xRoute rule.
					maxParallelRetries?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of pending requests that Envoy will queue to
					// the referenced backend defined within a xRoute rule.
					maxPendingRequests?: int64 & int & <=4294967295 & >=0 | *1024

					// The maximum number of requests that Envoy will make over a
					// single connection to the referenced backend defined within a
					// xRoute rule.
					// Default: unlimited.
					maxRequestsPerConnection?: uint32
				}

				// Connection includes backend connection settings.
				connection?: {
					// BufferLimit Soft limit on size of the cluster’s connections
					// read and write buffers.
					// BufferLimit applies to connection streaming (maybe
					// non-streaming) channel between processes, it's in user space.
					// If unspecified, an implementation defined default is applied
					// (32768 bytes).
					// For example, 20Mi, 1Gi, 256Ki etc.
					// Note: that when the suffix is not provided, the value is
					// interpreted as bytes.
					bufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

					// SocketBufferLimit provides configuration for the maximum buffer
					// size in bytes for each socket
					// to backend.
					// SocketBufferLimit applies to socket streaming channel between
					// TCP/IP stacks, it's in kernel space.
					// For example, 20Mi, 1Gi, 256Ki etc.
					// Note that when the suffix is not provided, the value is
					// interpreted as bytes.
					socketBufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])
				}

				// DNS includes dns resolution settings.
				dns?: {
					// DNSRefreshRate specifies the rate at which DNS records should
					// be refreshed.
					// Defaults to 30 seconds.
					dnsRefreshRate?: string

					// RespectDNSTTL indicates whether the DNS Time-To-Live (TTL)
					// should be respected.
					// If the value is set to true, the DNS refresh rate will be set
					// to the resource record’s TTL.
					// Defaults to true.
					respectDnsTtl?: bool
				}

				// HealthCheck allows gateway to perform active health checking on
				// backends.
				healthCheck?: {
					// Active health check configuration
					active?: {
						grpc?: {
							// Service to send in the health check request.
							// If this is not specified, then the health check request applies
							// to the entire
							// server and not to a specific service.
							service?: string
						}

						// HealthyThreshold defines the number of healthy health checks
						// required before a backend host is marked healthy.
						healthyThreshold?: int32 & int & >=1 | *1

						// HTTP defines the configuration of http health checker.
						// It's required while the health checker type is HTTP.
						http?: {
							// ExpectedResponse defines a list of HTTP expected responses to
							// match.
							expectedResponse?: {
								// Binary payload base64 encoded.
								binary?: string

								// Text payload in plain text.
								text?: string

								// Type defines the type of the payload.
								type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
							}

							// ExpectedStatuses defines a list of HTTP response statuses
							// considered healthy.
							// Defaults to 200 only
							expectedStatuses?: [...int & <600 & >=100]

							// Method defines the HTTP method used for health checking.
							// Defaults to GET
							method?: string

							// Path defines the HTTP path that will be requested during health
							// checking.
							path!: strings.MaxRunes(1024) & strings.MinRunes(1)
						}

						// Interval defines the time between active health checks.
						interval?: string | *"3s"

						// TCP defines the configuration of tcp health checker.
						// It's required while the health checker type is TCP.
						tcp?: {
							// Receive defines the expected response payload.
							receive?: {
								// Binary payload base64 encoded.
								binary?: string

								// Text payload in plain text.
								text?: string

								// Type defines the type of the payload.
								type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
							}

							// Send defines the request payload.
							send?: {
								// Binary payload base64 encoded.
								binary?: string

								// Text payload in plain text.
								text?: string

								// Type defines the type of the payload.
								type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
							}
						}

						// Timeout defines the time to wait for a health check response.
						timeout?: string | *"1s"

						// Type defines the type of health checker.
						type!: matchN(2, ["HTTP" | "TCP" | "GRPC", "HTTP" | "TCP" | "GRPC"])

						// UnhealthyThreshold defines the number of unhealthy health
						// checks required before a backend host is marked unhealthy.
						unhealthyThreshold?: int32 & int & >=1 | *3
					}

					// Passive passive check configuration
					passive?: {
						// BaseEjectionTime defines the base duration for which a host
						// will be ejected on consecutive failures.
						baseEjectionTime?: string | *"30s"

						// Consecutive5xxErrors sets the number of consecutive 5xx errors
						// triggering ejection.
						consecutive5XxErrors?: int32 & int | *5

						// ConsecutiveGatewayErrors sets the number of consecutive gateway
						// errors triggering ejection.
						consecutiveGatewayErrors?: int32 & int | *0

						// ConsecutiveLocalOriginFailures sets the number of consecutive
						// local origin failures triggering ejection.
						// Parameter takes effect only when
						// split_external_local_origin_errors is set to true.
						consecutiveLocalOriginFailures?: int32 & int | *5

						// Interval defines the time between passive health checks.
						interval?: string | *"3s"

						// MaxEjectionPercent sets the maximum percentage of hosts in a
						// cluster that can be ejected.
						maxEjectionPercent?: int32 & int | *10

						// SplitExternalLocalOriginErrors enables splitting of errors
						// between external and local origin.
						splitExternalLocalOriginErrors?: bool | *false
					}
				}

				// HTTP2 provides HTTP/2 configuration for backend connections.
				http2?: {
					// InitialConnectionWindowSize sets the initial window size for
					// HTTP/2 connections.
					// If not set, the default value is 1 MiB.
					initialConnectionWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

					// InitialStreamWindowSize sets the initial window size for HTTP/2
					// streams.
					// If not set, the default value is 64 KiB(64*1024).
					initialStreamWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

					// MaxConcurrentStreams sets the maximum number of concurrent
					// streams allowed per connection.
					// If not set, the default value is 100.
					maxConcurrentStreams?: int32 & >=1

					// OnInvalidMessage determines if Envoy will terminate the
					// connection or just the offending stream in the event of HTTP
					// messaging error
					// It's recommended for L2 Envoy deployments to set this value to
					// TerminateStream.
					// https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
					// Default: TerminateConnection
					onInvalidMessage?: string
				}

				// LoadBalancer policy to apply when routing traffic from the
				// gateway to
				// the backend endpoints. Defaults to `LeastRequest`.
				loadBalancer?: {
					// ConsistentHash defines the configuration when the load balancer
					// type is
					// set to ConsistentHash
					consistentHash?: {
						// Cookie configures the cookie hash policy when the consistent
						// hash type is set to Cookie.
						cookie?: {
							// Additional Attributes to set for the generated cookie.
							attributes?: close({
								[string]: string
							})

							// Name of the cookie to hash.
							// If this cookie does not exist in the request, Envoy will
							// generate a cookie and set
							// the TTL on the response back to the client based on Layer 4
							// attributes of the backend endpoint, to ensure that these future
							// requests
							// go to the same backend endpoint. Make sure to set the TTL field
							// for this case.
							name!: string

							// TTL of the generated cookie if the cookie is not present. This
							// value sets the
							// Max-Age attribute value.
							ttl?: string
						}
						header?: {
							// Name of the header to hash.
							name!: string
						}

						// The table size for consistent hashing, must be prime number
						// limited to 5000011.
						tableSize?: int64 & int & <=5000011 & >=2 | *65537

						// ConsistentHashType defines the type of input to hash on. Valid
						// Type values are
						// "SourceIP",
						// "Header",
						// "Cookie".
						type!: "SourceIP" | "Header" | "Cookie"
					}
					slowStart?: {
						// Window defines the duration of the warm up period for newly
						// added host.
						// During slow start window, traffic sent to the newly added hosts
						// will gradually increase.
						// Currently only supports linear growth of traffic. For
						// additional details,
						// see
						// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
						window!: string
					}

					// Type decides the type of Load Balancer policy.
					// Valid LoadBalancerType values are
					// "ConsistentHash",
					// "LeastRequest",
					// "Random",
					// "RoundRobin".
					type!: "ConsistentHash" | "LeastRequest" | "Random" | "RoundRobin"
				}
				proxyProtocol?: {
					// Version of ProxyProtol
					// Valid ProxyProtocolVersion values are
					// "V1"
					// "V2"
					version!: "V1" | "V2"
				}

				// Retry provides more advanced usage, allowing users to customize
				// the number of retries, retry fallback strategy, and retry
				// triggering conditions.
				// If not set, retry will be disabled.
				retry?: {
					// NumRetries is the number of retries to be attempted. Defaults
					// to 2.
					numRetries?: int32 & int & >=0 | *2

					// PerRetry is the retry policy to be applied per retry attempt.
					perRetry?: {
						// Backoff is the backoff policy to be applied per retry attempt.
						// gateway uses a fully jittered exponential
						// back-off algorithm for retries. For additional details,
						// see
						// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
						backOff?: {
							// BaseInterval is the base interval between retries.
							baseInterval?: string

							// MaxInterval is the maximum interval between retries. This
							// parameter is optional, but must be greater than or equal to
							// the base_interval if set.
							// The default is 10 times the base_interval
							maxInterval?: string
						}

						// Timeout is the timeout per retry attempt.
						timeout?: string
					}

					// RetryOn specifies the retry trigger condition.
					//
					// If not specified, the default is to retry on
					// connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
					retryOn?: {
						// HttpStatusCodes specifies the http status codes to be retried.
						// The retriable-status-codes trigger must also be configured for
						// these status codes to trigger a retry.
						httpStatusCodes?: [...int & <600 & >=100]

						// Triggers specifies the retry trigger condition(Http/Grpc).
						triggers?: [..."5xx" | "gateway-error" | "reset" | "connect-failure" | "retriable-4xx" | "refused-stream" | "retriable-status-codes" | "cancelled" | "deadline-exceeded" | "internal" | "resource-exhausted" | "unavailable"]
					}
				}

				// TcpKeepalive settings associated with the upstream client
				// connection.
				// Disabled by default.
				tcpKeepalive?: {
					// The duration a connection needs to be idle before keep-alive
					// probes start being sent.
					// The duration format is
					// Defaults to `7200s`.
					idleTime?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

					// The duration between keep-alive probes.
					// Defaults to `75s`.
					interval?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

					// The total number of unacknowledged probes to send before
					// deciding
					// the connection is dead.
					// Defaults to 9.
					probes?: int32
				}

				// Timeout settings for the backend connections.
				timeout?: {
					// Timeout settings for HTTP.
					http?: {
						// The idle timeout for an HTTP connection. Idle time is defined
						// as a period in which there are no active requests in the
						// connection.
						// Default: 1 hour.
						connectionIdleTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

						// The maximum duration of an HTTP connection.
						// Default: unlimited.
						maxConnectionDuration?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

						// RequestTimeout is the time until which entire response is
						// received from the upstream.
						requestTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
					}
					tcp?: {
						// The timeout for network connection establishment, including TCP
						// and TLS handshakes.
						// Default: 10 seconds.
						connectTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
					}
				}
			}

			// The OIDC Provider's [issuer
			// identifier](https://openid.net/specs/openid-connect-discovery-1_0.html#IssuerDiscovery).
			// Issuer MUST be a URI RFC 3986 [RFC3986] with a scheme component
			// that MUST
			// be https, a host component, and optionally, port and path
			// components and
			// no query or fragment components.
			issuer!: strings.MinRunes(1)

			// The OIDC Provider's [token
			// endpoint](https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint).
			// If not provided, EG will try to discover it from the provider's
			// [Well-Known Configuration
			// Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
			tokenEndpoint?: string
		}

		// The redirect URL to be used in the OIDC
		// [Authentication
		// Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
		// If not specified, uses the default redirect URI
		// "%REQ(x-forwarded-proto)%://%REQ(:authority)%/oauth2/callback"
		redirectURL?: string

		// RefreshToken indicates whether the Envoy should automatically
		// refresh the
		// id token and access token when they expire.
		// When set to true, the Envoy will use the refresh token to get a
		// new id token
		// and access token when they expire.
		//
		// If not specified, defaults to false.
		refreshToken?: bool

		// The OIDC resources to be used in the
		// [Authentication
		// Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
		resources?: [...string]

		// The OIDC scopes to be used in the
		// [Authentication
		// Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
		// The "openid" scope is always added to the list of scopes if not
		// already
		// specified.
		scopes?: [...string]
	}

	// TargetRef is the name of the resource this policy is being
	// attached to.
	// This policy and the TargetRef MUST be in the same namespace for
	// this
	// Policy to have effect
	//
	// Deprecated: use targetRefs/targetSelectors instead
	targetRef?: {
		// Group is the group of the target resource.
		group!: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name!: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}

	// TargetRefs are the names of the Gateway resources this policy
	// is being attached to.
	targetRefs?: [...{
		// Group is the group of the target resource.
		group!: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name!: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}]

	// TargetSelectors allow targeting resources for this policy based
	// on labels
	targetSelectors?: [...{
		// Group is the group that this selector targets. Defaults to
		// gateway.networking.k8s.io
		group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *"gateway.networking.k8s.io"

		// Kind is the resource kind that this selector targets.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// MatchLabels are the set of label selectors for identifying the
		// targeted resource
		matchLabels!: close({
			[string]: string
		})
	}]
}
