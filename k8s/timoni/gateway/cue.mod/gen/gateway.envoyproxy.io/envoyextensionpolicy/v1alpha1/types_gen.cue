// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f https://github.com/envoyproxy/gateway/releases/download/v1.3.0/install.yaml

package v1alpha1

import (
	"strings"
	"list"
)

// EnvoyExtensionPolicy allows the user to configure various envoy
// extensibility options for the Gateway.
#EnvoyExtensionPolicy: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "gateway.envoyproxy.io/v1alpha1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "EnvoyExtensionPolicy"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// Spec defines the desired state of EnvoyExtensionPolicy.
	spec!: #EnvoyExtensionPolicySpec
}

// Spec defines the desired state of EnvoyExtensionPolicy.
#EnvoyExtensionPolicySpec: {
	// ExtProc is an ordered list of external processing filters
	// that should be added to the envoy filter chain
	extProc?: list.MaxItems(16) & [...{
		// BackendRef references a Kubernetes object that represents the
		// backend server to which the authorization request will be sent.
		//
		// Deprecated: Use BackendRefs instead.
		backendRef?: {
			// Group is the group of the referent. For example,
			// "gateway.networking.k8s.io".
			// When unspecified or empty string, core API group is inferred.
			group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

			// Kind is the Kubernetes resource kind of the referent. For
			// example
			// "Service".
			//
			// Defaults to "Service" when not specified.
			//
			// ExternalName services can refer to CNAME DNS records that may
			// live
			// outside of the cluster and as such are difficult to reason
			// about in
			// terms of conformance. They also may not be safe to forward to
			// (see
			// CVE-2021-25740 for more information). Implementations SHOULD
			// NOT
			// support ExternalName Services.
			//
			// Support: Core (Services with a type other than ExternalName)
			//
			// Support: Implementation-specific (Services with type
			// ExternalName)
			kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

			// Name is the name of the referent.
			name!: strings.MaxRunes(253) & strings.MinRunes(1)

			// Namespace is the namespace of the backend. When unspecified,
			// the local
			// namespace is inferred.
			//
			// Note that when a namespace different than the local namespace
			// is specified,
			// a ReferenceGrant object is required in the referent namespace
			// to allow that
			// namespace's owner to accept the reference. See the
			// ReferenceGrant
			// documentation for details.
			//
			// Support: Core
			namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
			}

			// Port specifies the destination port number to use for this
			// resource.
			// Port is required when the referent is a Kubernetes Service. In
			// this
			// case, the port number is the service port number, not the
			// target port.
			// For other resources, destination port might be derived from the
			// referent
			// resource or this field.
			port?: uint16 & >=1
		}

		// BackendRefs references a Kubernetes object that represents the
		// backend server to which the authorization request will be sent.
		backendRefs?: list.MaxItems(16) & [...{
			// Fallback indicates whether the backend is designated as a
			// fallback.
			// Multiple fallback backends can be configured.
			// It is highly recommended to configure active or passive health
			// checks to ensure that failover can be detected
			// when the active backends become unhealthy and to automatically
			// readjust once the primary backends are healthy again.
			// The overprovisioning factor is set to 1.4, meaning the fallback
			// backends will only start receiving traffic when
			// the health of the active backends falls below 72%.
			fallback?: bool

			// Group is the group of the referent. For example,
			// "gateway.networking.k8s.io".
			// When unspecified or empty string, core API group is inferred.
			group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

			// Kind is the Kubernetes resource kind of the referent. For
			// example
			// "Service".
			//
			// Defaults to "Service" when not specified.
			//
			// ExternalName services can refer to CNAME DNS records that may
			// live
			// outside of the cluster and as such are difficult to reason
			// about in
			// terms of conformance. They also may not be safe to forward to
			// (see
			// CVE-2021-25740 for more information). Implementations SHOULD
			// NOT
			// support ExternalName Services.
			//
			// Support: Core (Services with a type other than ExternalName)
			//
			// Support: Implementation-specific (Services with type
			// ExternalName)
			kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Service"

			// Name is the name of the referent.
			name!: strings.MaxRunes(253) & strings.MinRunes(1)

			// Namespace is the namespace of the backend. When unspecified,
			// the local
			// namespace is inferred.
			//
			// Note that when a namespace different than the local namespace
			// is specified,
			// a ReferenceGrant object is required in the referent namespace
			// to allow that
			// namespace's owner to accept the reference. See the
			// ReferenceGrant
			// documentation for details.
			//
			// Support: Core
			namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
			}

			// Port specifies the destination port number to use for this
			// resource.
			// Port is required when the referent is a Kubernetes Service. In
			// this
			// case, the port number is the service port number, not the
			// target port.
			// For other resources, destination port might be derived from the
			// referent
			// resource or this field.
			port?: uint16 & >=1
		}]

		// BackendSettings holds configuration for managing the connection
		// to the backend.
		backendSettings?: {
			// Circuit Breaker settings for the upstream connections and
			// requests.
			// If not set, circuit breakers will be enabled with the default
			// thresholds
			circuitBreaker?: {
				// The maximum number of connections that Envoy will establish to
				// the referenced backend defined within a xRoute rule.
				maxConnections?: int64 & int & <=4294967295 & >=0 | *1024

				// The maximum number of parallel requests that Envoy will make to
				// the referenced backend defined within a xRoute rule.
				maxParallelRequests?: int64 & int & <=4294967295 & >=0 | *1024

				// The maximum number of parallel retries that Envoy will make to
				// the referenced backend defined within a xRoute rule.
				maxParallelRetries?: int64 & int & <=4294967295 & >=0 | *1024

				// The maximum number of pending requests that Envoy will queue to
				// the referenced backend defined within a xRoute rule.
				maxPendingRequests?: int64 & int & <=4294967295 & >=0 | *1024

				// The maximum number of requests that Envoy will make over a
				// single connection to the referenced backend defined within a
				// xRoute rule.
				// Default: unlimited.
				maxRequestsPerConnection?: uint32
			}

			// Connection includes backend connection settings.
			connection?: {
				// BufferLimit Soft limit on size of the cluster’s connections
				// read and write buffers.
				// BufferLimit applies to connection streaming (maybe
				// non-streaming) channel between processes, it's in user space.
				// If unspecified, an implementation defined default is applied
				// (32768 bytes).
				// For example, 20Mi, 1Gi, 256Ki etc.
				// Note: that when the suffix is not provided, the value is
				// interpreted as bytes.
				bufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

				// SocketBufferLimit provides configuration for the maximum buffer
				// size in bytes for each socket
				// to backend.
				// SocketBufferLimit applies to socket streaming channel between
				// TCP/IP stacks, it's in kernel space.
				// For example, 20Mi, 1Gi, 256Ki etc.
				// Note that when the suffix is not provided, the value is
				// interpreted as bytes.
				socketBufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])
			}

			// DNS includes dns resolution settings.
			dns?: {
				// DNSRefreshRate specifies the rate at which DNS records should
				// be refreshed.
				// Defaults to 30 seconds.
				dnsRefreshRate?: string

				// RespectDNSTTL indicates whether the DNS Time-To-Live (TTL)
				// should be respected.
				// If the value is set to true, the DNS refresh rate will be set
				// to the resource record’s TTL.
				// Defaults to true.
				respectDnsTtl?: bool
			}

			// HealthCheck allows gateway to perform active health checking on
			// backends.
			healthCheck?: {
				// Active health check configuration
				active?: {
					grpc?: {
						// Service to send in the health check request.
						// If this is not specified, then the health check request applies
						// to the entire
						// server and not to a specific service.
						service?: string
					}

					// HealthyThreshold defines the number of healthy health checks
					// required before a backend host is marked healthy.
					healthyThreshold?: int32 & int & >=1 | *1

					// HTTP defines the configuration of http health checker.
					// It's required while the health checker type is HTTP.
					http?: {
						// ExpectedResponse defines a list of HTTP expected responses to
						// match.
						expectedResponse?: {
							// Binary payload base64 encoded.
							binary?: string

							// Text payload in plain text.
							text?: string

							// Type defines the type of the payload.
							type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
						}

						// ExpectedStatuses defines a list of HTTP response statuses
						// considered healthy.
						// Defaults to 200 only
						expectedStatuses?: [...int & <600 & >=100]

						// Method defines the HTTP method used for health checking.
						// Defaults to GET
						method?: string

						// Path defines the HTTP path that will be requested during health
						// checking.
						path!: strings.MaxRunes(1024) & strings.MinRunes(1)
					}

					// Interval defines the time between active health checks.
					interval?: string | *"3s"

					// TCP defines the configuration of tcp health checker.
					// It's required while the health checker type is TCP.
					tcp?: {
						// Receive defines the expected response payload.
						receive?: {
							// Binary payload base64 encoded.
							binary?: string

							// Text payload in plain text.
							text?: string

							// Type defines the type of the payload.
							type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
						}

						// Send defines the request payload.
						send?: {
							// Binary payload base64 encoded.
							binary?: string

							// Text payload in plain text.
							text?: string

							// Type defines the type of the payload.
							type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
						}
					}

					// Timeout defines the time to wait for a health check response.
					timeout?: string | *"1s"

					// Type defines the type of health checker.
					type!: matchN(2, ["HTTP" | "TCP" | "GRPC", "HTTP" | "TCP" | "GRPC"])

					// UnhealthyThreshold defines the number of unhealthy health
					// checks required before a backend host is marked unhealthy.
					unhealthyThreshold?: int32 & int & >=1 | *3
				}

				// Passive passive check configuration
				passive?: {
					// BaseEjectionTime defines the base duration for which a host
					// will be ejected on consecutive failures.
					baseEjectionTime?: string | *"30s"

					// Consecutive5xxErrors sets the number of consecutive 5xx errors
					// triggering ejection.
					consecutive5XxErrors?: int32 & int | *5

					// ConsecutiveGatewayErrors sets the number of consecutive gateway
					// errors triggering ejection.
					consecutiveGatewayErrors?: int32 & int | *0

					// ConsecutiveLocalOriginFailures sets the number of consecutive
					// local origin failures triggering ejection.
					// Parameter takes effect only when
					// split_external_local_origin_errors is set to true.
					consecutiveLocalOriginFailures?: int32 & int | *5

					// Interval defines the time between passive health checks.
					interval?: string | *"3s"

					// MaxEjectionPercent sets the maximum percentage of hosts in a
					// cluster that can be ejected.
					maxEjectionPercent?: int32 & int | *10

					// SplitExternalLocalOriginErrors enables splitting of errors
					// between external and local origin.
					splitExternalLocalOriginErrors?: bool | *false
				}
			}

			// HTTP2 provides HTTP/2 configuration for backend connections.
			http2?: {
				// InitialConnectionWindowSize sets the initial window size for
				// HTTP/2 connections.
				// If not set, the default value is 1 MiB.
				initialConnectionWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

				// InitialStreamWindowSize sets the initial window size for HTTP/2
				// streams.
				// If not set, the default value is 64 KiB(64*1024).
				initialStreamWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

				// MaxConcurrentStreams sets the maximum number of concurrent
				// streams allowed per connection.
				// If not set, the default value is 100.
				maxConcurrentStreams?: int32 & >=1

				// OnInvalidMessage determines if Envoy will terminate the
				// connection or just the offending stream in the event of HTTP
				// messaging error
				// It's recommended for L2 Envoy deployments to set this value to
				// TerminateStream.
				// https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
				// Default: TerminateConnection
				onInvalidMessage?: string
			}

			// LoadBalancer policy to apply when routing traffic from the
			// gateway to
			// the backend endpoints. Defaults to `LeastRequest`.
			loadBalancer?: {
				// ConsistentHash defines the configuration when the load balancer
				// type is
				// set to ConsistentHash
				consistentHash?: {
					// Cookie configures the cookie hash policy when the consistent
					// hash type is set to Cookie.
					cookie?: {
						// Additional Attributes to set for the generated cookie.
						attributes?: close({
							[string]: string
						})

						// Name of the cookie to hash.
						// If this cookie does not exist in the request, Envoy will
						// generate a cookie and set
						// the TTL on the response back to the client based on Layer 4
						// attributes of the backend endpoint, to ensure that these future
						// requests
						// go to the same backend endpoint. Make sure to set the TTL field
						// for this case.
						name!: string

						// TTL of the generated cookie if the cookie is not present. This
						// value sets the
						// Max-Age attribute value.
						ttl?: string
					}
					header?: {
						// Name of the header to hash.
						name!: string
					}

					// The table size for consistent hashing, must be prime number
					// limited to 5000011.
					tableSize?: int64 & int & <=5000011 & >=2 | *65537

					// ConsistentHashType defines the type of input to hash on. Valid
					// Type values are
					// "SourceIP",
					// "Header",
					// "Cookie".
					type!: "SourceIP" | "Header" | "Cookie"
				}
				slowStart?: {
					// Window defines the duration of the warm up period for newly
					// added host.
					// During slow start window, traffic sent to the newly added hosts
					// will gradually increase.
					// Currently only supports linear growth of traffic. For
					// additional details,
					// see
					// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
					window!: string
				}

				// Type decides the type of Load Balancer policy.
				// Valid LoadBalancerType values are
				// "ConsistentHash",
				// "LeastRequest",
				// "Random",
				// "RoundRobin".
				type!: "ConsistentHash" | "LeastRequest" | "Random" | "RoundRobin"
			}
			proxyProtocol?: {
				// Version of ProxyProtol
				// Valid ProxyProtocolVersion values are
				// "V1"
				// "V2"
				version!: "V1" | "V2"
			}

			// Retry provides more advanced usage, allowing users to customize
			// the number of retries, retry fallback strategy, and retry
			// triggering conditions.
			// If not set, retry will be disabled.
			retry?: {
				// NumRetries is the number of retries to be attempted. Defaults
				// to 2.
				numRetries?: int32 & int & >=0 | *2

				// PerRetry is the retry policy to be applied per retry attempt.
				perRetry?: {
					// Backoff is the backoff policy to be applied per retry attempt.
					// gateway uses a fully jittered exponential
					// back-off algorithm for retries. For additional details,
					// see
					// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
					backOff?: {
						// BaseInterval is the base interval between retries.
						baseInterval?: string

						// MaxInterval is the maximum interval between retries. This
						// parameter is optional, but must be greater than or equal to
						// the base_interval if set.
						// The default is 10 times the base_interval
						maxInterval?: string
					}

					// Timeout is the timeout per retry attempt.
					timeout?: string
				}

				// RetryOn specifies the retry trigger condition.
				//
				// If not specified, the default is to retry on
				// connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
				retryOn?: {
					// HttpStatusCodes specifies the http status codes to be retried.
					// The retriable-status-codes trigger must also be configured for
					// these status codes to trigger a retry.
					httpStatusCodes?: [...int & <600 & >=100]

					// Triggers specifies the retry trigger condition(Http/Grpc).
					triggers?: [..."5xx" | "gateway-error" | "reset" | "connect-failure" | "retriable-4xx" | "refused-stream" | "retriable-status-codes" | "cancelled" | "deadline-exceeded" | "internal" | "resource-exhausted" | "unavailable"]
				}
			}

			// TcpKeepalive settings associated with the upstream client
			// connection.
			// Disabled by default.
			tcpKeepalive?: {
				// The duration a connection needs to be idle before keep-alive
				// probes start being sent.
				// The duration format is
				// Defaults to `7200s`.
				idleTime?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

				// The duration between keep-alive probes.
				// Defaults to `75s`.
				interval?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

				// The total number of unacknowledged probes to send before
				// deciding
				// the connection is dead.
				// Defaults to 9.
				probes?: int32
			}

			// Timeout settings for the backend connections.
			timeout?: {
				// Timeout settings for HTTP.
				http?: {
					// The idle timeout for an HTTP connection. Idle time is defined
					// as a period in which there are no active requests in the
					// connection.
					// Default: 1 hour.
					connectionIdleTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

					// The maximum duration of an HTTP connection.
					// Default: unlimited.
					maxConnectionDuration?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

					// RequestTimeout is the time until which entire response is
					// received from the upstream.
					requestTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
				}
				tcp?: {
					// The timeout for network connection establishment, including TCP
					// and TLS handshakes.
					// Default: 10 seconds.
					connectTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
				}
			}
		}

		// FailOpen defines if requests or responses that cannot be
		// processed due to connectivity to the
		// external processor are terminated or passed-through.
		// Default: false
		failOpen?: bool

		// MessageTimeout is the timeout for a response to be returned
		// from the external processor
		// Default: 200ms
		messageTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

		// Metadata defines options related to the sending and receiving
		// of dynamic metadata.
		// These options define which metadata namespaces would be sent to
		// the processor and which dynamic metadata
		// namespaces the processor would be permitted to emit metadata
		// to.
		// Users can specify custom namespaces or well-known envoy
		// metadata namespace (such as envoy.filters.http.ext_authz)
		// documented here:
		// https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata#well-known-dynamic-metadata
		// Default: no metadata context is sent or received from the
		// external processor
		metadata?: {
			// AccessibleNamespaces are metadata namespaces that are sent to
			// the external processor as context
			accessibleNamespaces?: [...string]

			// WritableNamespaces are metadata namespaces that the external
			// processor can write to
			writableNamespaces?: list.MaxItems(8) & [...string]
		}

		// ProcessingMode defines how request and response body is
		// processed
		// Default: header and body are not sent to the external processor
		processingMode?: {
			// AllowModeOverride allows the external processor to override the
			// processing mode set via the
			// `mode_override` field in the gRPC response message. This
			// defaults to false.
			allowModeOverride?: bool

			// Defines processing mode for requests. If present, request
			// headers are sent. Request body is processed according
			// to the specified mode.
			request?: {
				// Defines which attributes are sent to the external processor.
				// Envoy Gateway currently
				// supports only the following attribute prefixes: connection,
				// source, destination,
				// request, response, upstream and xds.route.
				// https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
				attributes?: [...=~"^(connection\\.|source\\.|destination\\.|request\\.|response\\.|upstream\\.|xds\\.route_)[a-z_1-9]*$"]

				// Defines body processing mode
				body?: "Streamed" | "Buffered" | "BufferedPartial"
			}

			// Defines processing mode for responses. If present, response
			// headers are sent. Response body is processed according
			// to the specified mode.
			response?: {
				// Defines which attributes are sent to the external processor.
				// Envoy Gateway currently
				// supports only the following attribute prefixes: connection,
				// source, destination,
				// request, response, upstream and xds.route.
				// https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
				attributes?: [...=~"^(connection\\.|source\\.|destination\\.|request\\.|response\\.|upstream\\.|xds\\.route_)[a-z_1-9]*$"]

				// Defines body processing mode
				body?: "Streamed" | "Buffered" | "BufferedPartial"
			}
		}
	}]

	// Lua is an ordered list of Lua filters
	// that should be added to the envoy filter chain
	lua?: list.MaxItems(16) & [...{
		// Inline contains the source code as an inline string.
		inline?: string

		// Type is the type of method to use to read the Lua value.
		// Valid values are Inline and ValueRef, default is Inline.
		type!: "Inline" | "ValueRef" | *"Inline"

		// ValueRef has the source code specified as a local object
		// reference.
		// Only a reference to ConfigMap is supported.
		// The value of key `lua` in the ConfigMap will be used.
		// If the key is not found, the first value in the ConfigMap will
		// be used.
		valueRef?: {
			// Group is the group of the referent. For example,
			// "gateway.networking.k8s.io".
			// When unspecified or empty string, core API group is inferred.
			group!: strings.MaxRunes(253) & {
				=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
			}

			// Kind is kind of the referent. For example "HTTPRoute" or
			// "Service".
			kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
			}

			// Name is the name of the referent.
			name!: strings.MaxRunes(253) & strings.MinRunes(1)
		}
	}]

	// TargetRef is the name of the resource this policy is being
	// attached to.
	// This policy and the TargetRef MUST be in the same namespace for
	// this
	// Policy to have effect
	//
	// Deprecated: use targetRefs/targetSelectors instead
	targetRef?: {
		// Group is the group of the target resource.
		group!: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name!: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}

	// TargetRefs are the names of the Gateway resources this policy
	// is being attached to.
	targetRefs?: [...{
		// Group is the group of the target resource.
		group!: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name!: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}]

	// TargetSelectors allow targeting resources for this policy based
	// on labels
	targetSelectors?: [...{
		// Group is the group that this selector targets. Defaults to
		// gateway.networking.k8s.io
		group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *"gateway.networking.k8s.io"

		// Kind is the resource kind that this selector targets.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// MatchLabels are the set of label selectors for identifying the
		// targeted resource
		matchLabels!: close({
			[string]: string
		})
	}]

	// Wasm is a list of Wasm extensions to be loaded by the Gateway.
	// Order matters, as the extensions will be loaded in the order
	// they are
	// defined in this list.
	wasm?: list.MaxItems(16) & [...{
		// Code is the Wasm code for the extension.
		code!: {
			// HTTP is the HTTP URL containing the Wasm code.
			//
			// Note that the HTTP server must be accessible from the Envoy
			// proxy.
			http?: {
				// SHA256 checksum that will be used to verify the Wasm code.
				//
				// If not specified, Envoy Gateway will not verify the downloaded
				// Wasm code.
				// kubebuilder:validation:Pattern=`^[a-f0-9]{64}$`
				sha256?: string

				// URL is the URL containing the Wasm code.
				url!: =~"^((https?:)(\\/\\/\\/?)([\\w]*(?::[\\w]*)?@)?([\\d\\w\\.-]+)(?::(\\d+))?)?([\\/\\\\\\w\\.()-]*)?(?:([?][^#]*)?(#.*)?)*"
			}

			// Image is the OCI image containing the Wasm code.
			//
			// Note that the image must be accessible from the Envoy Gateway.
			image?: {
				// PullSecretRef is a reference to the secret containing the
				// credentials to pull the image.
				// Only support Kubernetes Secret resource from the same
				// namespace.
				pullSecretRef?: {
					// Group is the group of the referent. For example,
					// "gateway.networking.k8s.io".
					// When unspecified or empty string, core API group is inferred.
					group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

					// Kind is kind of the referent. For example "Secret".
					kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Secret"

					// Name is the name of the referent.
					name!: strings.MaxRunes(253) & strings.MinRunes(1)

					// Namespace is the namespace of the referenced object. When
					// unspecified, the local
					// namespace is inferred.
					//
					// Note that when a namespace different than the local namespace
					// is specified,
					// a ReferenceGrant object is required in the referent namespace
					// to allow that
					// namespace's owner to accept the reference. See the
					// ReferenceGrant
					// documentation for details.
					//
					// Support: Core
					namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
					}
				}

				// SHA256 checksum that will be used to verify the OCI image.
				//
				// It must match the digest of the OCI image.
				//
				// If not specified, Envoy Gateway will not verify the downloaded
				// OCI image.
				// kubebuilder:validation:Pattern=`^[a-f0-9]{64}$`
				sha256?: string

				// URL is the URL of the OCI image.
				// URL can be in the format of `registry/image:tag` or
				// `registry/image@sha256:digest`.
				url!: string
			}

			// PullPolicy is the policy to use when pulling the Wasm module by
			// either the HTTP or Image source.
			// This field is only applicable when the SHA256 field is not set.
			//
			// If not specified, the default policy is IfNotPresent except for
			// OCI images whose tag is latest.
			//
			// Note: EG does not update the Wasm module every time an Envoy
			// proxy requests
			// the Wasm module even if the pull policy is set to Always.
			// It only updates the Wasm module when the EnvoyExtension
			// resource version changes.
			pullPolicy?: "IfNotPresent" | "Always"

			// Type is the type of the source of the Wasm code.
			// Valid WasmCodeSourceType values are "HTTP" or "Image".
			type!: matchN(2, ["HTTP" | "Image", "HTTP" | "Image" | "ConfigMap"])
		}

		// Config is the configuration for the Wasm extension.
		// This configuration will be passed as a JSON string to the Wasm
		// extension.
		config?: _
		env?: {
			// HostKeys is a list of keys for environment variables from the
			// host envoy process
			// that should be passed into the Wasm VM. This is useful for
			// passing secrets to to Wasm extensions.
			hostKeys?: [...string]
		}

		// FailOpen is a switch used to control the behavior when a fatal
		// error occurs
		// during the initialization or the execution of the Wasm
		// extension.
		// If FailOpen is set to true, the system bypasses the Wasm
		// extension and
		// allows the traffic to pass through. Otherwise, if it is set to
		// false or
		// not set (defaulting to false), the system blocks the traffic
		// and returns
		// an HTTP 5xx error.
		failOpen?: bool | *false

		// Name is a unique name for this Wasm extension. It is used to
		// identify the
		// Wasm extension if multiple extensions are handled by the same
		// vm_id and root_id.
		// It's also used for logging/debugging.
		// If not specified, EG will generate a unique name for the Wasm
		// extension.
		name?: string

		// RootID is a unique ID for a set of extensions in a VM which
		// will share a
		// RootContext and Contexts if applicable (e.g., an Wasm
		// HttpFilter and an Wasm AccessLog).
		// If left blank, all extensions with a blank root_id with the
		// same vm_id will share Context(s).
		//
		// Note: RootID must match the root_id parameter used to register
		// the Context in the Wasm code.
		rootID?: string
	}]
}
