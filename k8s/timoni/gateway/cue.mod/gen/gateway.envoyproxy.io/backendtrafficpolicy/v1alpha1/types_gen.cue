// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f https://github.com/envoyproxy/gateway/releases/download/v1.3.0/install.yaml

package v1alpha1

import (
	"strings"
	"list"
)

// BackendTrafficPolicy allows the user to configure the behavior
// of the connection
// between the Envoy Proxy listener and the backend service.
#BackendTrafficPolicy: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "gateway.envoyproxy.io/v1alpha1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "BackendTrafficPolicy"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// spec defines the desired state of BackendTrafficPolicy.
	spec!: #BackendTrafficPolicySpec
}

// spec defines the desired state of BackendTrafficPolicy.
#BackendTrafficPolicySpec: {
	// Circuit Breaker settings for the upstream connections and
	// requests.
	// If not set, circuit breakers will be enabled with the default
	// thresholds
	circuitBreaker?: {
		// The maximum number of connections that Envoy will establish to
		// the referenced backend defined within a xRoute rule.
		maxConnections?: int64 & int & <=4294967295 & >=0 | *1024

		// The maximum number of parallel requests that Envoy will make to
		// the referenced backend defined within a xRoute rule.
		maxParallelRequests?: int64 & int & <=4294967295 & >=0 | *1024

		// The maximum number of parallel retries that Envoy will make to
		// the referenced backend defined within a xRoute rule.
		maxParallelRetries?: int64 & int & <=4294967295 & >=0 | *1024

		// The maximum number of pending requests that Envoy will queue to
		// the referenced backend defined within a xRoute rule.
		maxPendingRequests?: int64 & int & <=4294967295 & >=0 | *1024

		// The maximum number of requests that Envoy will make over a
		// single connection to the referenced backend defined within a
		// xRoute rule.
		// Default: unlimited.
		maxRequestsPerConnection?: uint32
	}

	// The compression config for the http streams.
	compression?: [...{
		// The configuration for Brotli compressor.
		brotli?: {}

		// The configuration for GZIP compressor.
		gzip?: {}

		// CompressorType defines the compressor type to use for
		// compression.
		type!: "Gzip" | "Brotli"
	}]

	// Connection includes backend connection settings.
	connection?: {
		// BufferLimit Soft limit on size of the cluster’s connections
		// read and write buffers.
		// BufferLimit applies to connection streaming (maybe
		// non-streaming) channel between processes, it's in user space.
		// If unspecified, an implementation defined default is applied
		// (32768 bytes).
		// For example, 20Mi, 1Gi, 256Ki etc.
		// Note: that when the suffix is not provided, the value is
		// interpreted as bytes.
		bufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

		// SocketBufferLimit provides configuration for the maximum buffer
		// size in bytes for each socket
		// to backend.
		// SocketBufferLimit applies to socket streaming channel between
		// TCP/IP stacks, it's in kernel space.
		// For example, 20Mi, 1Gi, 256Ki etc.
		// Note that when the suffix is not provided, the value is
		// interpreted as bytes.
		socketBufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])
	}

	// DNS includes dns resolution settings.
	dns?: {
		// DNSRefreshRate specifies the rate at which DNS records should
		// be refreshed.
		// Defaults to 30 seconds.
		dnsRefreshRate?: string

		// RespectDNSTTL indicates whether the DNS Time-To-Live (TTL)
		// should be respected.
		// If the value is set to true, the DNS refresh rate will be set
		// to the resource record’s TTL.
		// Defaults to true.
		respectDnsTtl?: bool
	}

	// FaultInjection defines the fault injection policy to be
	// applied. This configuration can be used to
	// inject delays and abort requests to mimic failure scenarios
	// such as service failures and overloads
	faultInjection?: {
		// If specified, the request will be aborted if it meets the
		// configuration criteria.
		abort?: {
			// GrpcStatus specifies the GRPC status code to be returned
			grpcStatus?: int32

			// StatusCode specifies the HTTP status code to be returned
			httpStatus?: uint & >=200 & <=600

			// Percentage specifies the percentage of requests to be aborted.
			// Default 100%, if set 0, no requests will be aborted. Accuracy
			// to 0.0001%.
			percentage?: number | *100
		}

		// If specified, a delay will be injected into the request.
		delay?: {
			// FixedDelay specifies the fixed delay duration
			fixedDelay!: string

			// Percentage specifies the percentage of requests to be delayed.
			// Default 100%, if set 0, no requests will be delayed. Accuracy
			// to 0.0001%.
			percentage?: number | *100
		}
	}

	// HealthCheck allows gateway to perform active health checking on
	// backends.
	healthCheck?: {
		// Active health check configuration
		active?: {
			grpc?: {
				// Service to send in the health check request.
				// If this is not specified, then the health check request applies
				// to the entire
				// server and not to a specific service.
				service?: string
			}

			// HealthyThreshold defines the number of healthy health checks
			// required before a backend host is marked healthy.
			healthyThreshold?: int32 & int & >=1 | *1

			// HTTP defines the configuration of http health checker.
			// It's required while the health checker type is HTTP.
			http?: {
				// ExpectedResponse defines a list of HTTP expected responses to
				// match.
				expectedResponse?: {
					// Binary payload base64 encoded.
					binary?: string

					// Text payload in plain text.
					text?: string

					// Type defines the type of the payload.
					type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
				}

				// ExpectedStatuses defines a list of HTTP response statuses
				// considered healthy.
				// Defaults to 200 only
				expectedStatuses?: [...int & <600 & >=100]

				// Method defines the HTTP method used for health checking.
				// Defaults to GET
				method?: string

				// Path defines the HTTP path that will be requested during health
				// checking.
				path!: strings.MaxRunes(1024) & strings.MinRunes(1)
			}

			// Interval defines the time between active health checks.
			interval?: string | *"3s"

			// TCP defines the configuration of tcp health checker.
			// It's required while the health checker type is TCP.
			tcp?: {
				// Receive defines the expected response payload.
				receive?: {
					// Binary payload base64 encoded.
					binary?: string

					// Text payload in plain text.
					text?: string

					// Type defines the type of the payload.
					type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
				}

				// Send defines the request payload.
				send?: {
					// Binary payload base64 encoded.
					binary?: string

					// Text payload in plain text.
					text?: string

					// Type defines the type of the payload.
					type!: matchN(2, ["Text" | "Binary", "Text" | "Binary"])
				}
			}

			// Timeout defines the time to wait for a health check response.
			timeout?: string | *"1s"

			// Type defines the type of health checker.
			type!: matchN(2, ["HTTP" | "TCP" | "GRPC", "HTTP" | "TCP" | "GRPC"])

			// UnhealthyThreshold defines the number of unhealthy health
			// checks required before a backend host is marked unhealthy.
			unhealthyThreshold?: int32 & int & >=1 | *3
		}

		// Passive passive check configuration
		passive?: {
			// BaseEjectionTime defines the base duration for which a host
			// will be ejected on consecutive failures.
			baseEjectionTime?: string | *"30s"

			// Consecutive5xxErrors sets the number of consecutive 5xx errors
			// triggering ejection.
			consecutive5XxErrors?: int32 & int | *5

			// ConsecutiveGatewayErrors sets the number of consecutive gateway
			// errors triggering ejection.
			consecutiveGatewayErrors?: int32 & int | *0

			// ConsecutiveLocalOriginFailures sets the number of consecutive
			// local origin failures triggering ejection.
			// Parameter takes effect only when
			// split_external_local_origin_errors is set to true.
			consecutiveLocalOriginFailures?: int32 & int | *5

			// Interval defines the time between passive health checks.
			interval?: string | *"3s"

			// MaxEjectionPercent sets the maximum percentage of hosts in a
			// cluster that can be ejected.
			maxEjectionPercent?: int32 & int | *10

			// SplitExternalLocalOriginErrors enables splitting of errors
			// between external and local origin.
			splitExternalLocalOriginErrors?: bool | *false
		}
	}

	// HTTP2 provides HTTP/2 configuration for backend connections.
	http2?: {
		// InitialConnectionWindowSize sets the initial window size for
		// HTTP/2 connections.
		// If not set, the default value is 1 MiB.
		initialConnectionWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

		// InitialStreamWindowSize sets the initial window size for HTTP/2
		// streams.
		// If not set, the default value is 64 KiB(64*1024).
		initialStreamWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

		// MaxConcurrentStreams sets the maximum number of concurrent
		// streams allowed per connection.
		// If not set, the default value is 100.
		maxConcurrentStreams?: int32 & >=1

		// OnInvalidMessage determines if Envoy will terminate the
		// connection or just the offending stream in the event of HTTP
		// messaging error
		// It's recommended for L2 Envoy deployments to set this value to
		// TerminateStream.
		// https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
		// Default: TerminateConnection
		onInvalidMessage?: string
	}

	// LoadBalancer policy to apply when routing traffic from the
	// gateway to
	// the backend endpoints. Defaults to `LeastRequest`.
	loadBalancer?: {
		// ConsistentHash defines the configuration when the load balancer
		// type is
		// set to ConsistentHash
		consistentHash?: {
			// Cookie configures the cookie hash policy when the consistent
			// hash type is set to Cookie.
			cookie?: {
				// Additional Attributes to set for the generated cookie.
				attributes?: close({
					[string]: string
				})

				// Name of the cookie to hash.
				// If this cookie does not exist in the request, Envoy will
				// generate a cookie and set
				// the TTL on the response back to the client based on Layer 4
				// attributes of the backend endpoint, to ensure that these future
				// requests
				// go to the same backend endpoint. Make sure to set the TTL field
				// for this case.
				name!: string

				// TTL of the generated cookie if the cookie is not present. This
				// value sets the
				// Max-Age attribute value.
				ttl?: string
			}
			header?: {
				// Name of the header to hash.
				name!: string
			}

			// The table size for consistent hashing, must be prime number
			// limited to 5000011.
			tableSize?: int64 & int & <=5000011 & >=2 | *65537

			// ConsistentHashType defines the type of input to hash on. Valid
			// Type values are
			// "SourceIP",
			// "Header",
			// "Cookie".
			type!: "SourceIP" | "Header" | "Cookie"
		}
		slowStart?: {
			// Window defines the duration of the warm up period for newly
			// added host.
			// During slow start window, traffic sent to the newly added hosts
			// will gradually increase.
			// Currently only supports linear growth of traffic. For
			// additional details,
			// see
			// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
			window!: string
		}

		// Type decides the type of Load Balancer policy.
		// Valid LoadBalancerType values are
		// "ConsistentHash",
		// "LeastRequest",
		// "Random",
		// "RoundRobin".
		type!: "ConsistentHash" | "LeastRequest" | "Random" | "RoundRobin"
	}
	proxyProtocol?: {
		// Version of ProxyProtol
		// Valid ProxyProtocolVersion values are
		// "V1"
		// "V2"
		version!: "V1" | "V2"
	}

	// RateLimit allows the user to limit the number of incoming
	// requests
	// to a predefined value based on attributes within the traffic
	// flow.
	rateLimit?: {
		global?: {
			// Rules are a list of RateLimit selectors and limits. Each rule
			// and its
			// associated limit is applied in a mutually exclusive way. If a
			// request
			// matches multiple rules, each of their associated limits get
			// applied, so a
			// single request might increase the rate limit counters for
			// multiple rules
			// if selected. The rate limit service will return a logical OR of
			// the individual
			// rate limit decisions of all matching rules. For example, if a
			// request
			// matches two rules, one rate limited and one not, the final
			// decision will be
			// to rate limit the request.
			rules!: list.MaxItems(64) & [...{
				// ClientSelectors holds the list of select conditions to select
				// specific clients using attributes from the traffic flow.
				// All individual select conditions must hold True for this rule
				// and its limit to be applied.
				//
				// If no client selectors are specified, the rule applies to all
				// traffic of
				// the targeted Route.
				//
				// If the policy targets a Gateway, the rule applies to each Route
				// of the Gateway.
				// Please note that each Route has its own rate limit counters.
				// For example,
				// if a Gateway has two Routes, and the policy has a rule with
				// limit 10rps,
				// each Route will have its own 10rps limit.
				clientSelectors?: list.MaxItems(8) & [...{
					// Headers is a list of request headers to match. Multiple header
					// values are ANDed together,
					// meaning, a request MUST match all the specified headers.
					// At least one of headers or sourceCIDR condition must be
					// specified.
					headers?: list.MaxItems(16) & [...{
						// Invert specifies whether the value match result will be
						// inverted.
						// Do not set this field when Type="Distinct", implying matching
						// on any/all unique
						// values within the header.
						invert?: bool | *false

						// Name of the HTTP header.
						name!: strings.MaxRunes(256) & strings.MinRunes(1)

						// Type specifies how to match against the value of the header.
						type?: "Exact" | "RegularExpression" | "Distinct" | *"Exact"

						// Value within the HTTP header. Due to the
						// case-insensitivity of header names, "foo" and "Foo" are
						// considered equivalent.
						// Do not set this field when Type="Distinct", implying matching
						// on any/all unique
						// values within the header.
						value?: strings.MaxRunes(1024)
					}]

					// SourceCIDR is the client IP Address range to match on.
					// At least one of headers or sourceCIDR condition must be
					// specified.
					sourceCIDR?: {
						type?: "Exact" | "Distinct" | *"Exact"

						// Value is the IP CIDR that represents the range of Source IP
						// Addresses of the client.
						// These could also be the intermediate addresses through which
						// the request has flown through and is part of the
						// `X-Forwarded-For` header.
						// For example, `192.168.0.1/32`, `192.168.0.0/24`,
						// `001:db8::/64`.
						value!: strings.MaxRunes(256) & strings.MinRunes(1)
					}
				}]

				// Cost specifies the cost of requests and responses for the rule.
				//
				// This is optional and if not specified, the default behavior is
				// to reduce the rate limit counters by 1 on
				// the request path and do not reduce the rate limit counters on
				// the response path.
				cost?: {
					// Request specifies the number to reduce the rate limit counters
					// on the request path. If this is not specified, the default
					// behavior
					// is to reduce the rate limit counters by 1.
					//
					// When Envoy receives a request that matches the rule, it tries
					// to reduce the
					// rate limit counters by the specified number. If the counter
					// doesn't have
					// enough capacity, the request is rate limited.
					request?: {
						// From specifies where to get the rate limit cost. Currently,
						// only "Number" and "Metadata" are supported.
						from!: "Number" | "Metadata"

						// Metadata specifies the per-request metadata to retrieve the
						// usage number from.
						metadata?: {
							// Key is the key to retrieve the usage number from the filter
							// metadata.
							key!: string

							// Namespace is the namespace of the dynamic metadata.
							namespace!: string
						}

						// Number specifies the fixed usage number to reduce the rate
						// limit counters.
						// Using zero can be used to only check the rate limit counters
						// without reducing them.
						number?: int64
					}

					// Response specifies the number to reduce the rate limit counters
					// after the response is sent back to the client or the request
					// stream is closed.
					//
					// The cost is used to reduce the rate limit counters for the
					// matching requests.
					// Since the reduction happens after the request stream is
					// complete, the rate limit
					// won't be enforced for the current request, but for the
					// subsequent matching requests.
					//
					// This is optional and if not specified, the rate limit counters
					// are not reduced
					// on the response path.
					//
					// Currently, this is only supported for HTTP Global Rate Limits.
					response?: {
						// From specifies where to get the rate limit cost. Currently,
						// only "Number" and "Metadata" are supported.
						from!: "Number" | "Metadata"

						// Metadata specifies the per-request metadata to retrieve the
						// usage number from.
						metadata?: {
							// Key is the key to retrieve the usage number from the filter
							// metadata.
							key!: string

							// Namespace is the namespace of the dynamic metadata.
							namespace!: string
						}

						// Number specifies the fixed usage number to reduce the rate
						// limit counters.
						// Using zero can be used to only check the rate limit counters
						// without reducing them.
						number?: int64
					}
				}

				// Limit holds the rate limit values.
				// This limit is applied for traffic flows when the selectors
				// compute to True, causing the request to be counted towards the
				// limit.
				// The limit is enforced and the request is ratelimited, i.e. a
				// response with
				// 429 HTTP status code is sent back to the client when
				// the selected requests have reached the limit.
				limit!: {
					requests!: int

					// RateLimitUnit specifies the intervals for setting rate limits.
					// Valid RateLimitUnit values are "Second", "Minute", "Hour", and
					// "Day".
					unit!: "Second" | "Minute" | "Hour" | "Day"
				}
			}]
		}
		local?: {
			// Rules are a list of RateLimit selectors and limits. If a
			// request matches
			// multiple rules, the strictest limit is applied. For example, if
			// a request
			// matches two rules, one with 10rps and one with 20rps, the final
			// limit will
			// be based on the rule with 10rps.
			rules?: list.MaxItems(16) & [...{
				// ClientSelectors holds the list of select conditions to select
				// specific clients using attributes from the traffic flow.
				// All individual select conditions must hold True for this rule
				// and its limit to be applied.
				//
				// If no client selectors are specified, the rule applies to all
				// traffic of
				// the targeted Route.
				//
				// If the policy targets a Gateway, the rule applies to each Route
				// of the Gateway.
				// Please note that each Route has its own rate limit counters.
				// For example,
				// if a Gateway has two Routes, and the policy has a rule with
				// limit 10rps,
				// each Route will have its own 10rps limit.
				clientSelectors?: list.MaxItems(8) & [...{
					// Headers is a list of request headers to match. Multiple header
					// values are ANDed together,
					// meaning, a request MUST match all the specified headers.
					// At least one of headers or sourceCIDR condition must be
					// specified.
					headers?: list.MaxItems(16) & [...{
						// Invert specifies whether the value match result will be
						// inverted.
						// Do not set this field when Type="Distinct", implying matching
						// on any/all unique
						// values within the header.
						invert?: bool | *false

						// Name of the HTTP header.
						name!: strings.MaxRunes(256) & strings.MinRunes(1)

						// Type specifies how to match against the value of the header.
						type?: "Exact" | "RegularExpression" | "Distinct" | *"Exact"

						// Value within the HTTP header. Due to the
						// case-insensitivity of header names, "foo" and "Foo" are
						// considered equivalent.
						// Do not set this field when Type="Distinct", implying matching
						// on any/all unique
						// values within the header.
						value?: strings.MaxRunes(1024)
					}]

					// SourceCIDR is the client IP Address range to match on.
					// At least one of headers or sourceCIDR condition must be
					// specified.
					sourceCIDR?: {
						type?: "Exact" | "Distinct" | *"Exact"

						// Value is the IP CIDR that represents the range of Source IP
						// Addresses of the client.
						// These could also be the intermediate addresses through which
						// the request has flown through and is part of the
						// `X-Forwarded-For` header.
						// For example, `192.168.0.1/32`, `192.168.0.0/24`,
						// `001:db8::/64`.
						value!: strings.MaxRunes(256) & strings.MinRunes(1)
					}
				}]

				// Cost specifies the cost of requests and responses for the rule.
				//
				// This is optional and if not specified, the default behavior is
				// to reduce the rate limit counters by 1 on
				// the request path and do not reduce the rate limit counters on
				// the response path.
				cost?: {
					// Request specifies the number to reduce the rate limit counters
					// on the request path. If this is not specified, the default
					// behavior
					// is to reduce the rate limit counters by 1.
					//
					// When Envoy receives a request that matches the rule, it tries
					// to reduce the
					// rate limit counters by the specified number. If the counter
					// doesn't have
					// enough capacity, the request is rate limited.
					request?: {
						// From specifies where to get the rate limit cost. Currently,
						// only "Number" and "Metadata" are supported.
						from!: "Number" | "Metadata"

						// Metadata specifies the per-request metadata to retrieve the
						// usage number from.
						metadata?: {
							// Key is the key to retrieve the usage number from the filter
							// metadata.
							key!: string

							// Namespace is the namespace of the dynamic metadata.
							namespace!: string
						}

						// Number specifies the fixed usage number to reduce the rate
						// limit counters.
						// Using zero can be used to only check the rate limit counters
						// without reducing them.
						number?: int64
					}

					// Response specifies the number to reduce the rate limit counters
					// after the response is sent back to the client or the request
					// stream is closed.
					//
					// The cost is used to reduce the rate limit counters for the
					// matching requests.
					// Since the reduction happens after the request stream is
					// complete, the rate limit
					// won't be enforced for the current request, but for the
					// subsequent matching requests.
					//
					// This is optional and if not specified, the rate limit counters
					// are not reduced
					// on the response path.
					//
					// Currently, this is only supported for HTTP Global Rate Limits.
					response?: {
						// From specifies where to get the rate limit cost. Currently,
						// only "Number" and "Metadata" are supported.
						from!: "Number" | "Metadata"

						// Metadata specifies the per-request metadata to retrieve the
						// usage number from.
						metadata?: {
							// Key is the key to retrieve the usage number from the filter
							// metadata.
							key!: string

							// Namespace is the namespace of the dynamic metadata.
							namespace!: string
						}

						// Number specifies the fixed usage number to reduce the rate
						// limit counters.
						// Using zero can be used to only check the rate limit counters
						// without reducing them.
						number?: int64
					}
				}

				// Limit holds the rate limit values.
				// This limit is applied for traffic flows when the selectors
				// compute to True, causing the request to be counted towards the
				// limit.
				// The limit is enforced and the request is ratelimited, i.e. a
				// response with
				// 429 HTTP status code is sent back to the client when
				// the selected requests have reached the limit.
				limit!: {
					requests!: int

					// RateLimitUnit specifies the intervals for setting rate limits.
					// Valid RateLimitUnit values are "Second", "Minute", "Hour", and
					// "Day".
					unit!: "Second" | "Minute" | "Hour" | "Day"
				}
			}]
		}

		// Type decides the scope for the RateLimits.
		// Valid RateLimitType values are "Global" or "Local".
		type!: "Global" | "Local"
	}

	// ResponseOverride defines the configuration to override specific
	// responses with a custom one.
	// If multiple configurations are specified, the first one to
	// match wins.
	responseOverride?: [...{
		match!: {
			// Status code to match on. The match evaluates to true if any of
			// the matches are successful.
			statusCodes!: list.MaxItems(50) & [...{
				// Range contains the range of status codes.
				range?: {
					// End of the range, including the end value.
					end!: int

					// Start of the range, including the start value.
					start!: int
				}

				// Type is the type of value.
				// Valid values are Value and Range, default is Value.
				type!: matchN(2, ["Value" | "Range", "Value" | "Range"]) | *"Value"

				// Value contains the value of the status code.
				value?: int
			}] & [_, ...]
		}

		// Response configuration.
		response!: {
			// Body of the Custom Response
			body?: {
				// Inline contains the value as an inline string.
				inline?: string

				// Type is the type of method to use to read the body value.
				// Valid values are Inline and ValueRef, default is Inline.
				type!: matchN(2, ["Inline" | "ValueRef", "Inline" | "ValueRef"]) | *"Inline"

				// ValueRef contains the contents of the body
				// specified as a local object reference.
				// Only a reference to ConfigMap is supported.
				//
				// The value of key `response.body` in the ConfigMap will be used
				// as the response body.
				// If the key is not found, the first value in the ConfigMap will
				// be used.
				valueRef?: {
					// Group is the group of the referent. For example,
					// "gateway.networking.k8s.io".
					// When unspecified or empty string, core API group is inferred.
					group!: strings.MaxRunes(253) & {
						=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
					}

					// Kind is kind of the referent. For example "HTTPRoute" or
					// "Service".
					kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
					}

					// Name is the name of the referent.
					name!: strings.MaxRunes(253) & strings.MinRunes(1)
				}
			}

			// Content Type of the response. This will be set in the
			// Content-Type header.
			contentType?: string

			// Status Code of the Custom Response
			// If unset, does not override the status of response.
			statusCode?: int
		}
	}]

	// Retry provides more advanced usage, allowing users to customize
	// the number of retries, retry fallback strategy, and retry
	// triggering conditions.
	// If not set, retry will be disabled.
	retry?: {
		// NumRetries is the number of retries to be attempted. Defaults
		// to 2.
		numRetries?: int32 & int & >=0 | *2

		// PerRetry is the retry policy to be applied per retry attempt.
		perRetry?: {
			// Backoff is the backoff policy to be applied per retry attempt.
			// gateway uses a fully jittered exponential
			// back-off algorithm for retries. For additional details,
			// see
			// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
			backOff?: {
				// BaseInterval is the base interval between retries.
				baseInterval?: string

				// MaxInterval is the maximum interval between retries. This
				// parameter is optional, but must be greater than or equal to
				// the base_interval if set.
				// The default is 10 times the base_interval
				maxInterval?: string
			}

			// Timeout is the timeout per retry attempt.
			timeout?: string
		}

		// RetryOn specifies the retry trigger condition.
		//
		// If not specified, the default is to retry on
		// connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
		retryOn?: {
			// HttpStatusCodes specifies the http status codes to be retried.
			// The retriable-status-codes trigger must also be configured for
			// these status codes to trigger a retry.
			httpStatusCodes?: [...int & <600 & >=100]

			// Triggers specifies the retry trigger condition(Http/Grpc).
			triggers?: [..."5xx" | "gateway-error" | "reset" | "connect-failure" | "retriable-4xx" | "refused-stream" | "retriable-status-codes" | "cancelled" | "deadline-exceeded" | "internal" | "resource-exhausted" | "unavailable"]
		}
	}

	// TargetRef is the name of the resource this policy is being
	// attached to.
	// This policy and the TargetRef MUST be in the same namespace for
	// this
	// Policy to have effect
	//
	// Deprecated: use targetRefs/targetSelectors instead
	targetRef?: {
		// Group is the group of the target resource.
		group!: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name!: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}

	// TargetRefs are the names of the Gateway resources this policy
	// is being attached to.
	targetRefs?: [...{
		// Group is the group of the target resource.
		group!: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name!: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}]

	// TargetSelectors allow targeting resources for this policy based
	// on labels
	targetSelectors?: [...{
		// Group is the group that this selector targets. Defaults to
		// gateway.networking.k8s.io
		group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *"gateway.networking.k8s.io"

		// Kind is the resource kind that this selector targets.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// MatchLabels are the set of label selectors for identifying the
		// targeted resource
		matchLabels!: close({
			[string]: string
		})
	}]

	// TcpKeepalive settings associated with the upstream client
	// connection.
	// Disabled by default.
	tcpKeepalive?: {
		// The duration a connection needs to be idle before keep-alive
		// probes start being sent.
		// The duration format is
		// Defaults to `7200s`.
		idleTime?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

		// The duration between keep-alive probes.
		// Defaults to `75s`.
		interval?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

		// The total number of unacknowledged probes to send before
		// deciding
		// the connection is dead.
		// Defaults to 9.
		probes?: int32
	}

	// Timeout settings for the backend connections.
	timeout?: {
		// Timeout settings for HTTP.
		http?: {
			// The idle timeout for an HTTP connection. Idle time is defined
			// as a period in which there are no active requests in the
			// connection.
			// Default: 1 hour.
			connectionIdleTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

			// The maximum duration of an HTTP connection.
			// Default: unlimited.
			maxConnectionDuration?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

			// RequestTimeout is the time until which entire response is
			// received from the upstream.
			requestTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
		}
		tcp?: {
			// The timeout for network connection establishment, including TCP
			// and TLS handshakes.
			// Default: 10 seconds.
			connectTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
		}
	}

	// UseClientProtocol configures Envoy to prefer sending requests
	// to backends using
	// the same HTTP protocol that the incoming request used. Defaults
	// to false, which means
	// that Envoy will use the protocol indicated by the attached
	// BackendRef.
	useClientProtocol?: bool
}
