// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f https://github.com/envoyproxy/gateway/releases/download/v1.3.0/install.yaml

package v1alpha1

import (
	"strings"
	"list"
)

// ClientTrafficPolicy allows the user to configure the behavior
// of the connection
// between the downstream client and Envoy Proxy listener.
#ClientTrafficPolicy: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "gateway.envoyproxy.io/v1alpha1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "ClientTrafficPolicy"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// Spec defines the desired state of ClientTrafficPolicy.
	spec!: #ClientTrafficPolicySpec
}

// Spec defines the desired state of ClientTrafficPolicy.
#ClientTrafficPolicySpec: {
	// ClientIPDetectionSettings provides configuration for
	// determining the original client IP address for requests.
	clientIPDetection?: {
		// CustomHeader provides configuration for determining the client
		// IP address for a request based on
		// a trusted custom HTTP header. This uses the custom_header
		// original IP detection extension.
		// Refer to
		// https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/http/original_ip_detection/custom_header/v3/custom_header.proto
		// for more details.
		customHeader?: {
			// FailClosed is a switch used to control the flow of traffic when
			// client IP detection
			// fails. If set to true, the listener will respond with 403
			// Forbidden when the client
			// IP address cannot be determined.
			failClosed?: bool

			// Name of the header containing the original downstream remote
			// address, if present.
			name!: strings.MaxRunes(255) & strings.MinRunes(1) & {
				=~"^[A-Za-z0-9-]+$"
			}
		}

		// XForwardedForSettings provides configuration for using
		// X-Forwarded-For headers for determining the client IP address.
		xForwardedFor?: {
			// NumTrustedHops controls the number of additional ingress proxy
			// hops from the right side of XFF HTTP
			// headers to trust when determining the origin client's IP
			// address.
			// Only one of NumTrustedHops and TrustedCIDRs must be set.
			numTrustedHops?: int32

			// TrustedCIDRs is a list of CIDR ranges to trust when evaluating
			// the remote IP address to determine the original clientâ€™s IP
			// address.
			// When the remote IP address matches a trusted CIDR and the
			// x-forwarded-for header was sent,
			// each entry in the x-forwarded-for header is evaluated from
			// right to left
			// and the first public non-trusted address is used as the
			// original client address.
			// If all addresses in x-forwarded-for are within the trusted
			// list, the first (leftmost) entry is used.
			// Only one of NumTrustedHops and TrustedCIDRs must be set.
			trustedCIDRs?: [...=~"((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]+))|((([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/([0-9]+))"] & [_, ...]
		}
	}

	// Connection includes client connection settings.
	connection?: {
		// BufferLimit provides configuration for the maximum buffer size
		// in bytes for each incoming connection.
		// BufferLimit applies to connection streaming (maybe
		// non-streaming) channel between processes, it's in user space.
		// For example, 20Mi, 1Gi, 256Ki etc.
		// Note that when the suffix is not provided, the value is
		// interpreted as bytes.
		// Default: 32768 bytes.
		bufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

		// ConnectionLimit defines limits related to connections
		connectionLimit?: {
			// CloseDelay defines the delay to use before closing connections
			// that are rejected
			// once the limit value is reached.
			// Default: none.
			closeDelay?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

			// Value of the maximum concurrent connections limit.
			// When the limit is reached, incoming connections will be closed
			// after the CloseDelay duration.
			value!: int64 & >=1
		}

		// SocketBufferLimit provides configuration for the maximum buffer
		// size in bytes for each incoming socket.
		// SocketBufferLimit applies to socket streaming channel between
		// TCP/IP stacks, it's in kernel space.
		// For example, 20Mi, 1Gi, 256Ki etc.
		// Note that when the suffix is not provided, the value is
		// interpreted as bytes.
		socketBufferLimit?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])
	}

	// EnableProxyProtocol interprets the ProxyProtocol header and
	// adds the
	// Client Address into the X-Forwarded-For header.
	// Note Proxy Protocol must be present when this field is set,
	// else the connection
	// is closed.
	enableProxyProtocol?: bool

	// HeaderSettings provides configuration for header management.
	headers?: {
		// DisableRateLimitHeaders configures Envoy Proxy to omit the
		// "X-RateLimit-" response headers
		// when rate limiting is enabled.
		disableRateLimitHeaders?: bool

		// EarlyRequestHeaders defines settings for early request header
		// modification, before envoy performs
		// routing, tracing and built-in header manipulation.
		earlyRequestHeaders?: {
			// Add adds the given header(s) (name, value) to the request
			// before the action. It appends to any existing values associated
			// with the header name.
			//
			// Input:
			// GET /foo HTTP/1.1
			// my-header: foo
			//
			// Config:
			// add:
			// - name: "my-header"
			// value: "bar,baz"
			//
			// Output:
			// GET /foo HTTP/1.1
			// my-header: foo,bar,baz
			add?: list.MaxItems(16) & [...{
				// Name is the name of the HTTP Header to be matched. Name
				// matching MUST be
				// case insensitive. (See
				// https://tools.ietf.org/html/rfc7230#section-3.2).
				//
				// If multiple entries specify equivalent header names, the first
				// entry with
				// an equivalent name MUST be considered for a match. Subsequent
				// entries
				// with an equivalent header name MUST be ignored. Due to the
				// case-insensitivity of header names, "foo" and "Foo" are
				// considered
				// equivalent.
				name!: strings.MaxRunes(256) & strings.MinRunes(1) & {
					=~"^[A-Za-z0-9!#$%&'*+\\-.^_\\x60|~]+$"
				}

				// Value is the value of HTTP Header to be matched.
				value!: strings.MaxRunes(4096) & strings.MinRunes(1)
			}]

			// Remove the given header(s) from the HTTP request before the
			// action. The
			// value of Remove is a list of HTTP header names. Note that the
			// header
			// names are case-insensitive (see
			// https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
			//
			// Input:
			// GET /foo HTTP/1.1
			// my-header1: foo
			// my-header2: bar
			// my-header3: baz
			//
			// Config:
			// remove: ["my-header1", "my-header3"]
			//
			// Output:
			// GET /foo HTTP/1.1
			// my-header2: bar
			remove?: list.MaxItems(16) & [...string]

			// Set overwrites the request with the given header (name, value)
			// before the action.
			//
			// Input:
			// GET /foo HTTP/1.1
			// my-header: foo
			//
			// Config:
			// set:
			// - name: "my-header"
			// value: "bar"
			//
			// Output:
			// GET /foo HTTP/1.1
			// my-header: bar
			set?: list.MaxItems(16) & [...{
				// Name is the name of the HTTP Header to be matched. Name
				// matching MUST be
				// case insensitive. (See
				// https://tools.ietf.org/html/rfc7230#section-3.2).
				//
				// If multiple entries specify equivalent header names, the first
				// entry with
				// an equivalent name MUST be considered for a match. Subsequent
				// entries
				// with an equivalent header name MUST be ignored. Due to the
				// case-insensitivity of header names, "foo" and "Foo" are
				// considered
				// equivalent.
				name!: strings.MaxRunes(256) & strings.MinRunes(1) & {
					=~"^[A-Za-z0-9!#$%&'*+\\-.^_\\x60|~]+$"
				}

				// Value is the value of HTTP Header to be matched.
				value!: strings.MaxRunes(4096) & strings.MinRunes(1)
			}]
		}

		// EnableEnvoyHeaders configures Envoy Proxy to add the "X-Envoy-"
		// headers to requests
		// and responses.
		enableEnvoyHeaders?: bool

		// PreserveXRequestID configures Envoy to keep the X-Request-ID
		// header if passed for a request that is edge
		// (Edge request is the request from external clients to front
		// Envoy) and not reset it, which is the current Envoy behaviour.
		// It defaults to false.
		preserveXRequestID?: bool

		// WithUnderscoresAction configures the action to take when an
		// HTTP header with underscores
		// is encountered. The default action is to reject the request.
		withUnderscoresAction?: "Allow" | "RejectRequest" | "DropHeader"

		// XForwardedClientCert configures how Envoy Proxy handle the
		// x-forwarded-client-cert (XFCC) HTTP header.
		//
		// x-forwarded-client-cert (XFCC) is an HTTP header used to
		// forward the certificate
		// information of part or all of the clients or proxies that a
		// request has flowed through,
		// on its way from the client to the server.
		//
		// Envoy proxy may choose to sanitize/append/forward the XFCC
		// header before proxying the request.
		//
		// If not set, the default behavior is sanitizing the XFCC header.
		xForwardedClientCert?: {
			// CertDetailsToAdd specifies the fields in the client certificate
			// to be forwarded in the XFCC header.
			//
			// Hash(the SHA 256 digest of the current client certificate) and
			// By(the Subject Alternative Name)
			// are always included if the client certificate is forwarded.
			//
			// This field is only applicable when the mode is set to
			// `AppendForward` or
			// `SanitizeSet` and the client connection is mTLS.
			certDetailsToAdd?: list.MaxItems(5) & [..."Subject" | "Cert" | "Chain" | "DNS" | "URI"]

			// Mode defines how XFCC header is handled by Envoy Proxy.
			// If not set, the default mode is `Sanitize`.
			mode?: "Sanitize" | "ForwardOnly" | "AppendForward" | "SanitizeSet" | "AlwaysForwardOnly"
		}
	}
	healthCheck?: {
		// Path specifies the HTTP path to match on for health check
		// requests.
		path!: strings.MaxRunes(1024) & strings.MinRunes(1)
	}

	// HTTP1 provides HTTP/1 configuration on the listener.
	http1?: {
		// EnableTrailers defines if HTTP/1 trailers should be proxied by
		// Envoy.
		enableTrailers?: bool
		http10?: {
			// UseDefaultHost defines if the HTTP/1.0 request is missing the
			// Host header,
			// then the hostname associated with the listener should be
			// injected into the
			// request.
			// If this is not set and an HTTP/1.0 request arrives without a
			// host, then
			// it will be rejected.
			useDefaultHost?: bool
		}

		// PreserveHeaderCase defines if Envoy should preserve the letter
		// case of headers.
		// By default, Envoy will lowercase all the headers.
		preserveHeaderCase?: bool
	}

	// HTTP2 provides HTTP/2 configuration on the listener.
	http2?: {
		// InitialConnectionWindowSize sets the initial window size for
		// HTTP/2 connections.
		// If not set, the default value is 1 MiB.
		initialConnectionWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

		// InitialStreamWindowSize sets the initial window size for HTTP/2
		// streams.
		// If not set, the default value is 64 KiB(64*1024).
		initialStreamWindowSize?: matchN(2, [null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}, null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}]) & matchN(>=1, [int, string])

		// MaxConcurrentStreams sets the maximum number of concurrent
		// streams allowed per connection.
		// If not set, the default value is 100.
		maxConcurrentStreams?: int32 & >=1

		// OnInvalidMessage determines if Envoy will terminate the
		// connection or just the offending stream in the event of HTTP
		// messaging error
		// It's recommended for L2 Envoy deployments to set this value to
		// TerminateStream.
		// https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
		// Default: TerminateConnection
		onInvalidMessage?: string
	}

	// HTTP3 provides HTTP/3 configuration on the listener.
	http3?: {}

	// Path enables managing how the incoming path set by clients can
	// be normalized.
	path?: {
		// DisableMergeSlashes allows disabling the default configuration
		// of merging adjacent
		// slashes in the path.
		// Note that slash merging is not part of the HTTP spec and is
		// provided for convenience.
		disableMergeSlashes?: bool

		// EscapedSlashesAction determines how %2f, %2F, %5c, or %5C
		// sequences in the path URI
		// should be handled.
		// The default is UnescapeAndRedirect.
		escapedSlashesAction?: "KeepUnchanged" | "RejectRequest" | "UnescapeAndForward" | "UnescapeAndRedirect"
	}

	// TargetRef is the name of the resource this policy is being
	// attached to.
	// This policy and the TargetRef MUST be in the same namespace for
	// this
	// Policy to have effect
	//
	// Deprecated: use targetRefs/targetSelectors instead
	targetRef?: {
		// Group is the group of the target resource.
		group!: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name!: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}

	// TargetRefs are the names of the Gateway resources this policy
	// is being attached to.
	targetRefs?: [...{
		// Group is the group of the target resource.
		group!: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name!: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}]

	// TargetSelectors allow targeting resources for this policy based
	// on labels
	targetSelectors?: [...{
		// Group is the group that this selector targets. Defaults to
		// gateway.networking.k8s.io
		group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *"gateway.networking.k8s.io"

		// Kind is the resource kind that this selector targets.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// MatchLabels are the set of label selectors for identifying the
		// targeted resource
		matchLabels!: close({
			[string]: string
		})
	}]

	// TcpKeepalive settings associated with the downstream client
	// connection.
	// If defined, sets SO_KEEPALIVE on the listener socket to enable
	// TCP Keepalives.
	// Disabled by default.
	tcpKeepalive?: {
		// The duration a connection needs to be idle before keep-alive
		// probes start being sent.
		// The duration format is
		// Defaults to `7200s`.
		idleTime?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

		// The duration between keep-alive probes.
		// Defaults to `75s`.
		interval?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

		// The total number of unacknowledged probes to send before
		// deciding
		// the connection is dead.
		// Defaults to 9.
		probes?: int32
	}

	// Timeout settings for the client connections.
	timeout?: {
		// Timeout settings for HTTP.
		http?: {
			// IdleTimeout for an HTTP connection. Idle time is defined as a
			// period in which there are no active requests in the
			// connection.
			// Default: 1 hour.
			idleTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

			// RequestReceivedTimeout is the duration envoy waits for the
			// complete request reception. This timer starts upon request
			// initiation and stops when either the last byte of the request
			// is sent upstream or when the response begins.
			requestReceivedTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
		}
		tcp?: {
			// IdleTimeout for a TCP connection. Idle time is defined as a
			// period in which there are no
			// bytes sent or received on either the upstream or downstream
			// connection.
			// Default: 1 hour.
			idleTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
		}
	}

	// TLS settings configure TLS termination settings with the
	// downstream client.
	tls?: {
		// ALPNProtocols supplies the list of ALPN protocols that should
		// be
		// exposed by the listener or used by the proxy to connect to the
		// backend.
		// Defaults:
		// 1. HTTPS Routes: h2 and http/1.1 are enabled in listener
		// context.
		// 2. Other Routes: ALPN is disabled.
		// 3. Backends: proxy uses the appropriate ALPN options for the
		// backend protocol.
		// When an empty list is provided, the ALPN TLS extension is
		// disabled.
		// Supported values are:
		// - http/1.0
		// - http/1.1
		// - h2
		alpnProtocols?: [..."http/1.0" | "http/1.1" | "h2"]

		// Ciphers specifies the set of cipher suites supported when
		// negotiating TLS 1.0 - 1.2. This setting has no effect for TLS
		// 1.3.
		// In non-FIPS Envoy Proxy builds the default cipher list is:
		// - [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
		// - [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
		// - ECDHE-ECDSA-AES256-GCM-SHA384
		// - ECDHE-RSA-AES256-GCM-SHA384
		// In builds using BoringSSL FIPS the default cipher list is:
		// - ECDHE-ECDSA-AES128-GCM-SHA256
		// - ECDHE-RSA-AES128-GCM-SHA256
		// - ECDHE-ECDSA-AES256-GCM-SHA384
		// - ECDHE-RSA-AES256-GCM-SHA384
		ciphers?: [...string]

		// ClientValidation specifies the configuration to validate the
		// client
		// initiating the TLS connection to the Gateway listener.
		clientValidation?: {
			// CACertificateRefs contains one or more references to
			// Kubernetes objects that contain TLS certificates of
			// the Certificate Authorities that can be used
			// as a trust anchor to validate the certificates presented by the
			// client.
			//
			// A single reference to a Kubernetes ConfigMap or a Kubernetes
			// Secret,
			// with the CA certificate in a key named `ca.crt` is currently
			// supported.
			//
			// References to a resource in different namespace are invalid
			// UNLESS there
			// is a ReferenceGrant in the target namespace that allows the
			// certificate
			// to be attached.
			caCertificateRefs?: list.MaxItems(8) & [...{
				// Group is the group of the referent. For example,
				// "gateway.networking.k8s.io".
				// When unspecified or empty string, core API group is inferred.
				group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *""

				// Kind is kind of the referent. For example "Secret".
				kind?: strings.MaxRunes(63) & strings.MinRunes(1) & =~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$" | *"Secret"

				// Name is the name of the referent.
				name!: strings.MaxRunes(253) & strings.MinRunes(1)

				// Namespace is the namespace of the referenced object. When
				// unspecified, the local
				// namespace is inferred.
				//
				// Note that when a namespace different than the local namespace
				// is specified,
				// a ReferenceGrant object is required in the referent namespace
				// to allow that
				// namespace's owner to accept the reference. See the
				// ReferenceGrant
				// documentation for details.
				//
				// Support: Core
				namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
				}
			}]

			// Optional set to true accepts connections even when a client
			// doesn't present a certificate.
			// Defaults to false, which rejects connections without a valid
			// client certificate.
			optional?: bool
		}

		// ECDHCurves specifies the set of supported ECDH curves.
		// In non-FIPS Envoy Proxy builds the default curves are:
		// - X25519
		// - P-256
		// In builds using BoringSSL FIPS the default curve is:
		// - P-256
		ecdhCurves?: [...string]

		// Max specifies the maximal TLS protocol version to allow
		// The default is TLS 1.3 if this is not specified.
		maxVersion?: "Auto" | "1.0" | "1.1" | "1.2" | "1.3"

		// Min specifies the minimal TLS protocol version to allow.
		// The default is TLS 1.2 if this is not specified.
		minVersion?: "Auto" | "1.0" | "1.1" | "1.2" | "1.3"
		session?: {
			// Resumption determines the proxy's supported TLS session
			// resumption option.
			// By default, Envoy Gateway does not enable session resumption.
			// Use sessionResumption to
			// enable stateful and stateless session resumption. Users should
			// consider security impacts
			// of different resumption methods. Performance gains from
			// resumption are diminished when
			// Envoy proxy is deployed with more than one replica.
			resumption?: {
				// Stateful defines setting for stateful (session-id based)
				// session resumption
				stateful?: {}

				// Stateless defines setting for stateless (session-ticket based)
				// session resumption
				stateless?: {}
			}
		}

		// SignatureAlgorithms specifies which signature algorithms the
		// listener should
		// support.
		signatureAlgorithms?: [...string]
	}
}
